{
    "sourceFile": "RealtimeSTT/audio_recorder.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1757304021130,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1757304021130,
            "name": "Commit-0",
            "content": "\n\"\"\"\n\nThe AudioToTextRecorder class in the provided code facilitates\nfast speech-to-text transcription.\n\nThe class employs the faster_whisper library to transcribe the recorded audio\ninto text using machine learning models, which can be run either on a GPU or\nCPU. Voice activity detection (VAD) is built in, meaning the software can\nautomatically start or stop recording based on the presence or absence of\nspeech. It integrates wake word detection through the pvporcupine library,\nallowing the software to initiate recording when a specific word or phrase\nis spoken. The system provides real-time feedback and can be further\ncustomized.\n\nFeatures:\n- Voice Activity Detection: Automatically starts/stops recording when speech\n  is detected or when speech ends.\n- Wake Word Detection: Starts recording when a specified wake word (or words)\n  is detected.\n- Event Callbacks: Customizable callbacks for when recording starts\n  or finishes.\n- Fast Transcription: Returns the transcribed text from the audio as fast\n  as possible.\n\nAuthor: Kolja Beigel\n\n\"\"\"\n\nfrom faster_whisper import WhisperModel, BatchedInferencePipeline\nfrom typing import Iterable, List, Optional, Union\nfrom openwakeword.model import Model\nimport torch.multiprocessing as mp\nfrom scipy.signal import resample\nimport signal as system_signal\nfrom ctypes import c_bool\nfrom scipy import signal\nfrom .safepipe import SafePipe\nimport soundfile as sf\nimport faster_whisper\nimport openwakeword\nimport collections\nimport numpy as np\nimport pvporcupine\nimport traceback\nimport threading\nimport webrtcvad\nimport datetime\nimport platform\nimport logging\nimport struct\nimport base64\nimport queue\nimport torch\nimport halo\nimport time\nimport copy\nimport os\nimport re\nimport gc\nimport types\n\n# Named logger for this module.\nlogger = logging.getLogger(\"realtimestt\")\nlogger.propagate = False\n\n# Set OpenMP runtime duplicate library handling to OK (Use only for development!)\nos.environ[\"KMP_DUPLICATE_LIB_OK\"] = \"TRUE\"\n\nINIT_MODEL_TRANSCRIPTION = \"tiny\"\nINIT_MODEL_TRANSCRIPTION_REALTIME = \"tiny\"\nINIT_REALTIME_PROCESSING_PAUSE = 0.2\nINIT_REALTIME_INITIAL_PAUSE = 0.2\nINIT_SILERO_SENSITIVITY = 0.4\nINIT_WEBRTC_SENSITIVITY = 3\nINIT_POST_SPEECH_SILENCE_DURATION = 0.6\nINIT_MIN_LENGTH_OF_RECORDING = 0.5\nINIT_MIN_GAP_BETWEEN_RECORDINGS = 0\nINIT_WAKE_WORDS_SENSITIVITY = 0.6\nINIT_PRE_RECORDING_BUFFER_DURATION = 1.0\nINIT_WAKE_WORD_ACTIVATION_DELAY = 0.0\nINIT_WAKE_WORD_TIMEOUT = 5.0\nINIT_WAKE_WORD_BUFFER_DURATION = 0.1\nALLOWED_LATENCY_LIMIT = 100\n\nTIME_SLEEP = 0.02\nSAMPLE_RATE = 16000\nBUFFER_SIZE = 512\nINT16_MAX_ABS_VALUE = 32768.0\n\nINIT_HANDLE_BUFFER_OVERFLOW = False\nif platform.system() != \"Darwin\":\n    INIT_HANDLE_BUFFER_OVERFLOW = True\n\n\nclass TranscriptionWorker:\n    def __init__(\n        self,\n        conn,\n        stdout_pipe,\n        model_path,\n        download_root,\n        compute_type,\n        gpu_device_index,\n        device,\n        backend,\n        ready_event,\n        shutdown_event,\n        interrupt_stop_event,\n        beam_size,\n        initial_prompt,\n        suppress_tokens,\n        batch_size,\n        faster_whisper_vad_filter,\n        normalize_audio,\n    ):\n        self.conn = conn\n        self.stdout_pipe = stdout_pipe\n        self.model_path = model_path\n        self.download_root = download_root\n        self.compute_type = compute_type\n        self.gpu_device_index = gpu_device_index\n        self.device = device\n        self.backend = backend if backend else \"whisper\"\n        self.ready_event = ready_event\n        self.shutdown_event = shutdown_event\n        self.interrupt_stop_event = interrupt_stop_event\n        self.beam_size = beam_size\n        self.initial_prompt = initial_prompt\n        self.suppress_tokens = suppress_tokens\n        self.batch_size = batch_size\n        self.faster_whisper_vad_filter = faster_whisper_vad_filter\n        self.normalize_audio = normalize_audio\n        self.queue = queue.Queue()\n\n    def custom_print(self, *args, **kwargs):\n        message = \" \".join(map(str, args))\n        try:\n            self.stdout_pipe.send(message)\n        except (BrokenPipeError, EOFError, OSError):\n            pass\n\n    def poll_connection(self):\n        while not self.shutdown_event.is_set():\n            try:\n                # Use a longer timeout to reduce polling frequency\n                if self.conn.poll(0.01):  # Increased from 0.01 to 0.5 seconds\n                    data = self.conn.recv()\n                    self.queue.put(data)\n                else:\n                    # Sleep only if no data, but use a shorter sleep\n                    time.sleep(TIME_SLEEP)\n            except Exception as e:\n                logging.error(\n                    f\"Error receiving data from connection: {e}\", exc_info=True\n                )\n                time.sleep(TIME_SLEEP)\n\n    def run(self):\n        # Ensure os module available even if overshadowed\n        import os  # noqa: F401\n\n        if __name__ == \"__main__\":\n            system_signal.signal(system_signal.SIGINT, system_signal.SIG_IGN)\n            __builtins__[\"print\"] = self.custom_print\n\n        if self.backend == \"whisper\":\n            logging.info(\n                f\"Initializing faster_whisper main transcription model {self.model_path}\"\n            )\n            try:\n                model = faster_whisper.WhisperModel(\n                    model_size_or_path=self.model_path,\n                    device=self.device,\n                    compute_type=self.compute_type,\n                    device_index=self.gpu_device_index,\n                    download_root=self.download_root,\n                )\n                if self.batch_size > 0:\n                    model = BatchedInferencePipeline(model=model)\n                current_dir = os.path.dirname(os.path.realpath(__file__))\n                warmup_audio_path = os.path.join(current_dir, \"warmup_audio.wav\")\n                warmup_audio_data, _ = sf.read(warmup_audio_path, dtype=\"float32\")\n                segments, info = model.transcribe(\n                    warmup_audio_data, language=\"en\", beam_size=1\n                )\n                model_warmup_transcription = \" \".join(\n                    segment.text for segment in segments\n                )\n            except Exception as e:\n                logging.exception(\n                    f\"Error initializing main faster_whisper transcription model: {e}\"\n                )\n                raise\n        elif self.backend == \"parakeet\":\n            logging.info(\n                f\"Initializing Parakeet (onnx-asr) main transcription model {self.model_path}\"\n            )\n            try:\n                try:\n                    import onnx_asr  # type: ignore\n                except ImportError as ie:\n                    raise RuntimeError(\n                        \"onnx_asr package not installed. Please install with 'pip install onnx-asr[gpu,hub]' to use Parakeet backend.\"\n                    ) from ie\n\n                # Enforce GPU availability if device requested is CUDA\n                try:\n                    import onnxruntime as ort  # type: ignore\n\n                    available_providers = set(ort.get_available_providers())\n                    if self.device == \"cuda\":\n                        if \"CUDAExecutionProvider\" not in available_providers:\n                            raise RuntimeError(\n                                \"CUDAExecutionProvider not available in onnxruntime. Parakeet requires GPU but only CPU providers were found: \"\n                                f\"{available_providers}. Install GPU runtime: 'pip install --upgrade onnxruntime-gpu' and ensure CUDA (and optionally TensorRT) libraries are in PATH.\"\n                            )\n                        # Optional: suppress TensorRT provider errors if TensorRT libs absent\n                        if \"TensorrtExecutionProvider\" not in available_providers:\n                            os.environ.setdefault(\"ORT_DISABLE_TENSORRT\", \"1\")\n                except ImportError:\n                    if self.device == \"cuda\":\n                        raise RuntimeError(\n                            \"onnxruntime not installed but required to validate GPU providers. Install with 'pip install onnxruntime-gpu'.\"\n                        )\n\n                # Allow some common aliases\n                parakeet_aliases = {\n                    \"parakeet-tdt-0.6b-v2-onnx\": \"nemo-parakeet-tdt-0.6b-v2\",\n                    \"nvidia/parakeet-tdt-0.6b-v2\": \"nemo-parakeet-tdt-0.6b-v2\",\n                    \"parakeet_v2\": \"nemo-parakeet-tdt-0.6b-v2\",\n                }\n                model_id = parakeet_aliases.get(self.model_path, self.model_path)\n                model = onnx_asr.load_model(model_id)\n\n                # Warm-up using bundled warmup audio\n                current_dir = os.path.dirname(os.path.realpath(__file__))\n                warmup_audio_path = os.path.join(current_dir, \"warmup_audio.wav\")\n                try:\n                    _ = model.recognize(warmup_audio_path)\n                except Exception:\n                    logging.warning(\n                        \"Parakeet warmup failed, continuing anyway\", exc_info=True\n                    )\n            except Exception as e:\n                logging.exception(\n                    f\"Error initializing Parakeet transcription model: {e}\"\n                )\n                raise\n        else:\n            raise ValueError(f\"Unsupported backend: {self.backend}\")\n\n        self.ready_event.set()\n        logging.debug(\n            f\"Main speech to text transcription model initialized successfully (backend={self.backend})\"\n        )\n\n        # Start the polling thread\n        polling_thread = threading.Thread(target=self.poll_connection)\n        polling_thread.start()\n\n        try:\n            while not self.shutdown_event.is_set():\n                try:\n                    audio, language, use_prompt = self.queue.get(timeout=0.1)\n                    try:\n                        logging.debug(f\"Transcribing audio with language {language}\")\n                        start_t = time.time()\n\n                        # normalize audio to -0.95 dBFS\n                        if audio is not None and audio.size > 0:\n                            if self.normalize_audio:\n                                peak = np.max(np.abs(audio))\n                                if peak > 0:\n                                    audio = (audio / peak) * 0.95\n                        else:\n                            logging.error(\"Received None audio for transcription\")\n                            self.conn.send(\n                                (\"error\", \"Received None audio for transcription\")\n                            )\n                            continue\n\n                        prompt = None\n                        if use_prompt:\n                            prompt = (\n                                self.initial_prompt if self.initial_prompt else None\n                            )\n\n                        if self.backend == \"whisper\":\n                            if self.batch_size > 0:\n                                segments, info = model.transcribe(\n                                    audio,\n                                    language=language if language else None,\n                                    beam_size=self.beam_size,\n                                    initial_prompt=prompt,\n                                    suppress_tokens=self.suppress_tokens,\n                                    batch_size=self.batch_size,\n                                    vad_filter=self.faster_whisper_vad_filter,\n                                )\n                            else:\n                                segments, info = model.transcribe(\n                                    audio,\n                                    language=language if language else None,\n                                    beam_size=self.beam_size,\n                                    initial_prompt=prompt,\n                                    suppress_tokens=self.suppress_tokens,\n                                    vad_filter=self.faster_whisper_vad_filter,\n                                )\n                            elapsed = time.time() - start_t\n                            transcription = \" \".join(\n                                seg.text for seg in segments\n                            ).strip()\n                            logging.debug(\n                                f\"Final text detected with main model: {transcription} in {elapsed:.4f}s\"\n                            )\n                            self.conn.send((\"success\", (segments, info)))\n                        elif self.backend == \"parakeet\":\n                            # Parakeet via onnx_asr returns plain text; fabricate minimal info object\n                            import tempfile, soundfile as psf, types, os\n\n                            tmpf = tempfile.NamedTemporaryFile(\n                                suffix=\".wav\", delete=False\n                            )\n                            tmp_name = tmpf.name\n                            tmpf.close()\n                            try:\n                                psf.write(tmp_name, audio, 16000)\n                                transcription = model.recognize(tmp_name).strip()\n                            finally:\n                                try:\n                                    os.unlink(tmp_name)\n                                except OSError:\n                                    pass\n                            info_obj = types.SimpleNamespace(\n                                language=\"en\", language_probability=1.0\n                            )\n                            Segment = lambda t: types.SimpleNamespace(text=t)\n                            segments = [Segment(transcription)] if transcription else []\n                            elapsed = time.time() - start_t\n                            logging.debug(\n                                f\"Final text detected with Parakeet model: {transcription} in {elapsed:.4f}s\"\n                            )\n                            self.conn.send((\"success\", (segments, info_obj)))\n                        else:\n                            raise ValueError(\n                                f\"Unsupported backend during transcription: {self.backend}\"\n                            )\n                    except Exception as e:\n                        logging.error(\n                            f\"General error in transcription: {e}\", exc_info=True\n                        )\n                        self.conn.send((\"error\", str(e)))\n                except queue.Empty:\n                    continue\n                except KeyboardInterrupt:\n                    self.interrupt_stop_event.set()\n                    logging.debug(\n                        \"Transcription worker process finished due to KeyboardInterrupt\"\n                    )\n                    break\n                except Exception as e:\n                    logging.error(\n                        f\"General error in processing queue item: {e}\", exc_info=True\n                    )\n        finally:\n            __builtins__[\"print\"] = print  # Restore the original print function\n            self.conn.close()\n            self.stdout_pipe.close()\n            self.shutdown_event.set()  # Ensure the polling thread will stop\n            polling_thread.join()  # Wait for the polling thread to finish\n\n\nclass bcolors:\n    OKGREEN = \"\\033[92m\"  # Green for active speech detection\n    WARNING = \"\\033[93m\"  # Yellow for silence detection\n    ENDC = \"\\033[0m\"  # Reset to default color\n\n\nclass AudioToTextRecorder:\n    \"\"\"\n    A class responsible for capturing audio from the microphone, detecting\n    voice activity, and then transcribing the captured audio using the\n    `faster_whisper` model.\n    \"\"\"\n\n    def __init__(\n        self,\n        model: str = INIT_MODEL_TRANSCRIPTION,\n        download_root: str = None,\n        language: str = \"\",\n        compute_type: str = \"default\",\n        stt_backend: str = \"whisper\",\n        input_device_index: int = None,\n        gpu_device_index: Union[int, List[int]] = 0,\n        device: str = \"cuda\",\n        on_recording_start=None,\n        on_recording_stop=None,\n        on_transcription_start=None,\n        ensure_sentence_starting_uppercase=True,\n        ensure_sentence_ends_with_period=True,\n        use_microphone=True,\n        spinner=True,\n        level=logging.WARNING,\n        batch_size: int = 16,\n        # Realtime transcription parameters\n        enable_realtime_transcription=False,\n        use_main_model_for_realtime=False,\n        realtime_model_type=INIT_MODEL_TRANSCRIPTION_REALTIME,\n        realtime_processing_pause=INIT_REALTIME_PROCESSING_PAUSE,\n        init_realtime_after_seconds=INIT_REALTIME_INITIAL_PAUSE,\n        on_realtime_transcription_update=None,\n        on_realtime_transcription_stabilized=None,\n        realtime_batch_size: int = 16,\n        # Voice activation parameters\n        silero_sensitivity: float = INIT_SILERO_SENSITIVITY,\n        silero_use_onnx: bool = False,\n        silero_deactivity_detection: bool = False,\n        webrtc_sensitivity: int = INIT_WEBRTC_SENSITIVITY,\n        post_speech_silence_duration: float = (INIT_POST_SPEECH_SILENCE_DURATION),\n        min_length_of_recording: float = (INIT_MIN_LENGTH_OF_RECORDING),\n        min_gap_between_recordings: float = (INIT_MIN_GAP_BETWEEN_RECORDINGS),\n        pre_recording_buffer_duration: float = (INIT_PRE_RECORDING_BUFFER_DURATION),\n        on_vad_start=None,\n        on_vad_stop=None,\n        on_vad_detect_start=None,\n        on_vad_detect_stop=None,\n        on_turn_detection_start=None,\n        on_turn_detection_stop=None,\n        # Wake word parameters\n        wakeword_backend: str = \"\",\n        openwakeword_model_paths: str = None,\n        openwakeword_inference_framework: str = \"onnx\",\n        wake_words: str = \"\",\n        wake_words_sensitivity: float = INIT_WAKE_WORDS_SENSITIVITY,\n        wake_word_activation_delay: float = (INIT_WAKE_WORD_ACTIVATION_DELAY),\n        wake_word_timeout: float = INIT_WAKE_WORD_TIMEOUT,\n        wake_word_buffer_duration: float = INIT_WAKE_WORD_BUFFER_DURATION,\n        on_wakeword_detected=None,\n        on_wakeword_timeout=None,\n        on_wakeword_detection_start=None,\n        on_wakeword_detection_end=None,\n        on_recorded_chunk=None,\n        debug_mode=False,\n        handle_buffer_overflow: bool = INIT_HANDLE_BUFFER_OVERFLOW,\n        beam_size: int = 5,\n        beam_size_realtime: int = 3,\n        buffer_size: int = BUFFER_SIZE,\n        sample_rate: int = SAMPLE_RATE,\n        initial_prompt: Optional[Union[str, Iterable[int]]] = None,\n        initial_prompt_realtime: Optional[Union[str, Iterable[int]]] = None,\n        suppress_tokens: Optional[List[int]] = [-1],\n        print_transcription_time: bool = False,\n        early_transcription_on_silence: int = 0,\n        allowed_latency_limit: int = ALLOWED_LATENCY_LIMIT,\n        no_log_file: bool = False,\n        use_extended_logging: bool = False,\n        faster_whisper_vad_filter: bool = True,\n        normalize_audio: bool = False,\n        start_callback_in_new_thread: bool = False,\n        force_threading: bool = False,\n    ):\n        \"\"\"\n        Initializes an audio recorder and  transcription\n        and wake word detection.\n\n        Args:\n        - model (str, default=\"tiny\"): Specifies the size of the transcription\n            model to use or the path to a converted model directory.\n            Valid options are 'tiny', 'tiny.en', 'base', 'base.en',\n            'small', 'small.en', 'medium', 'medium.en', 'large-v1',\n            'large-v2'.\n            If a specific size is provided, the model is downloaded\n            from the Hugging Face Hub.\n        - download_root (str, default=None): Specifies the root path were the Whisper models\n          are downloaded to. When empty, the default is used.\n        - language (str, default=\"\"): Language code for speech-to-text engine.\n            If not specified, the model will attempt to detect the language\n            automatically.\n        - compute_type (str, default=\"default\"): Specifies the type of\n            computation to be used for transcription.\n            See https://opennmt.net/CTranslate2/quantization.html.\n        - input_device_index (int, default=0): The index of the audio input\n            device to use.\n        - gpu_device_index (int, default=0): Device ID to use.\n            The model can also be loaded on multiple GPUs by passing a list of\n            IDs (e.g. [0, 1, 2, 3]). In that case, multiple transcriptions can\n            run in parallel when transcribe() is called from multiple Python\n            threads\n        - device (str, default=\"cuda\"): Device for model to use. Can either be\n            \"cuda\" or \"cpu\".\n        - on_recording_start (callable, default=None): Callback function to be\n            called when recording of audio to be transcripted starts.\n        - on_recording_stop (callable, default=None): Callback function to be\n            called when recording of audio to be transcripted stops.\n        - on_transcription_start (callable, default=None): Callback function\n            to be called when transcription of audio to text starts.\n        - ensure_sentence_starting_uppercase (bool, default=True): Ensures\n            that every sentence detected by the algorithm starts with an\n            uppercase letter.\n        - ensure_sentence_ends_with_period (bool, default=True): Ensures that\n            every sentence that doesn't end with punctuation such as \"?\", \"!\"\n            ends with a period\n        - use_microphone (bool, default=True): Specifies whether to use the\n            microphone as the audio input source. If set to False, the\n            audio input source will be the audio data sent through the\n            feed_audio() method.\n        - spinner (bool, default=True): Show spinner animation with current\n            state.\n        - level (int, default=logging.WARNING): Logging level.\n        - batch_size (int, default=16): Batch size for the main transcription\n        - enable_realtime_transcription (bool, default=False): Enables or\n            disables real-time transcription of audio. When set to True, the\n            audio will be transcribed continuously as it is being recorded.\n        - use_main_model_for_realtime (str, default=False):\n            If True, use the main transcription model for both regular and\n            real-time transcription. If False, use a separate model specified\n            by realtime_model_type for real-time transcription.\n            Using a single model can save memory and potentially improve\n            performance, but may not be optimized for real-time processing.\n            Using separate models allows for a smaller, faster model for\n            real-time transcription while keeping a more accurate model for\n            final transcription.\n        - realtime_model_type (str, default=\"tiny\"): Specifies the machine\n            learning model to be used for real-time transcription. Valid\n            options include 'tiny', 'tiny.en', 'base', 'base.en', 'small',\n            'small.en', 'medium', 'medium.en', 'large-v1', 'large-v2'.\n        - realtime_processing_pause (float, default=0.1): Specifies the time\n            interval in seconds after a chunk of audio gets transcribed. Lower\n            values will result in more \"real-time\" (frequent) transcription\n            updates but may increase computational load.\n        - init_realtime_after_seconds (float, default=0.2): Specifies the\n            initial waiting time after the recording was initiated before\n            yielding the first realtime transcription\n        - on_realtime_transcription_update = A callback function that is\n            triggered whenever there's an update in the real-time\n            transcription. The function is called with the newly transcribed\n            text as its argument.\n        - on_realtime_transcription_stabilized = A callback function that is\n            triggered when the transcribed text stabilizes in quality. The\n            stabilized text is generally more accurate but may arrive with a\n            slight delay compared to the regular real-time updates.\n        - realtime_batch_size (int, default=16): Batch size for the real-time\n            transcription model.\n        - silero_sensitivity (float, default=SILERO_SENSITIVITY): Sensitivity\n            for the Silero Voice Activity Detection model ranging from 0\n            (least sensitive) to 1 (most sensitive). Default is 0.5.\n        - silero_use_onnx (bool, default=False): Enables usage of the\n            pre-trained model from Silero in the ONNX (Open Neural Network\n            Exchange) format instead of the PyTorch format. This is\n            recommended for faster performance.\n        - silero_deactivity_detection (bool, default=False): Enables the Silero\n            model for end-of-speech detection. More robust against background\n            noise. Utilizes additional GPU resources but improves accuracy in\n            noisy environments. When False, uses the default WebRTC VAD,\n            which is more sensitive but may continue recording longer due\n            to background sounds.\n        - webrtc_sensitivity (int, default=WEBRTC_SENSITIVITY): Sensitivity\n            for the WebRTC Voice Activity Detection engine ranging from 0\n            (least aggressive / most sensitive) to 3 (most aggressive,\n            least sensitive). Default is 3.\n        - post_speech_silence_duration (float, default=0.2): Duration in\n            seconds of silence that must follow speech before the recording\n            is considered to be completed. This ensures that any brief\n            pauses during speech don't prematurely end the recording.\n        - min_gap_between_recordings (float, default=1.0): Specifies the\n            minimum time interval in seconds that should exist between the\n            end of one recording session and the beginning of another to\n            prevent rapid consecutive recordings.\n        - min_length_of_recording (float, default=1.0): Specifies the minimum\n            duration in seconds that a recording session should last to ensure\n            meaningful audio capture, preventing excessively short or\n            fragmented recordings.\n        - pre_recording_buffer_duration (float, default=0.2): Duration in\n            seconds for the audio buffer to maintain pre-roll audio\n            (compensates speech activity detection latency)\n        - on_vad_start (callable, default=None): Callback function to be called\n            when the system detected the start of voice activity presence.\n        - on_vad_stop (callable, default=None): Callback function to be called\n            when the system detected the stop (end) of voice activity presence.\n        - on_vad_detect_start (callable, default=None): Callback function to\n            be called when the system listens for voice activity. This is not\n            called when VAD actually happens (use on_vad_start for this), but\n            when the system starts listening for it.\n        - on_vad_detect_stop (callable, default=None): Callback function to be\n            called when the system stops listening for voice activity. This is\n            not called when VAD actually stops (use on_vad_stop for this), but\n            when the system stops listening for it.\n        - on_turn_detection_start (callable, default=None): Callback function\n            to be called when the system starts to listen for a turn of speech.\n        - on_turn_detection_stop (callable, default=None): Callback function to\n            be called when the system stops listening for a turn of speech.\n        - wakeword_backend (str, default=\"\"): Specifies the backend library to\n            use for wake word detection. Supported options include 'pvporcupine'\n            for using the Porcupine wake word engine or 'oww' for using the\n            OpenWakeWord engine.\n        - wakeword_backend (str, default=\"pvporcupine\"): Specifies the backend\n            library to use for wake word detection. Supported options include\n            'pvporcupine' for using the Porcupine wake word engine or 'oww' for\n            using the OpenWakeWord engine.\n        - openwakeword_model_paths (str, default=None): Comma-separated paths\n            to model files for the openwakeword library. These paths point to\n            custom models that can be used for wake word detection when the\n            openwakeword library is selected as the wakeword_backend.\n        - openwakeword_inference_framework (str, default=\"onnx\"): Specifies\n            the inference framework to use with the openwakeword library.\n            Can be either 'onnx' for Open Neural Network Exchange format\n            or 'tflite' for TensorFlow Lite.\n        - wake_words (str, default=\"\"): Comma-separated string of wake words to\n            initiate recording when using the 'pvporcupine' wakeword backend.\n            Supported wake words include: 'alexa', 'americano', 'blueberry',\n            'bumblebee', 'computer', 'grapefruits', 'grasshopper', 'hey google',\n            'hey siri', 'jarvis', 'ok google', 'picovoice', 'porcupine',\n            'terminator'. For the 'openwakeword' backend, wake words are\n            automatically extracted from the provided model files, so specifying\n            them here is not necessary.\n        - wake_words_sensitivity (float, default=0.5): Sensitivity for wake\n            word detection, ranging from 0 (least sensitive) to 1 (most\n            sensitive). Default is 0.5.\n        - wake_word_activation_delay (float, default=0): Duration in seconds\n            after the start of monitoring before the system switches to wake\n            word activation if no voice is initially detected. If set to\n            zero, the system uses wake word activation immediately.\n        - wake_word_timeout (float, default=5): Duration in seconds after a\n            wake word is recognized. If no subsequent voice activity is\n            detected within this window, the system transitions back to an\n            inactive state, awaiting the next wake word or voice activation.\n        - wake_word_buffer_duration (float, default=0.1): Duration in seconds\n            to buffer audio data during wake word detection. This helps in\n            cutting out the wake word from the recording buffer so it does not\n            falsely get detected along with the following spoken text, ensuring\n            cleaner and more accurate transcription start triggers.\n            Increase this if parts of the wake word get detected as text.\n        - on_wakeword_detected (callable, default=None): Callback function to\n            be called when a wake word is detected.\n        - on_wakeword_timeout (callable, default=None): Callback function to\n            be called when the system goes back to an inactive state after when\n            no speech was detected after wake word activation\n        - on_wakeword_detection_start (callable, default=None): Callback\n             function to be called when the system starts to listen for wake\n             words\n        - on_wakeword_detection_end (callable, default=None): Callback\n            function to be called when the system stops to listen for\n            wake words (e.g. because of timeout or wake word detected)\n        - on_recorded_chunk (callable, default=None): Callback function to be\n            called when a chunk of audio is recorded. The function is called\n            with the recorded audio chunk as its argument.\n        - debug_mode (bool, default=False): If set to True, the system will\n            print additional debug information to the console.\n        - handle_buffer_overflow (bool, default=True): If set to True, the system\n            will log a warning when an input overflow occurs during recording and\n            remove the data from the buffer.\n        - beam_size (int, default=5): The beam size to use for beam search\n            decoding.\n        - beam_size_realtime (int, default=3): The beam size to use for beam\n            search decoding in the real-time transcription model.\n        - buffer_size (int, default=512): The buffer size to use for audio\n            recording. Changing this may break functionality.\n        - sample_rate (int, default=16000): The sample rate to use for audio\n            recording. Changing this will very probably functionality (as the\n            WebRTC VAD model is very sensitive towards the sample rate).\n        - initial_prompt (str or iterable of int, default=None): Initial\n            prompt to be fed to the main transcription model.\n        - initial_prompt_realtime (str or iterable of int, default=None):\n            Initial prompt to be fed to the real-time transcription model.\n        - suppress_tokens (list of int, default=[-1]): Tokens to be suppressed\n            from the transcription output.\n        - print_transcription_time (bool, default=False): Logs processing time\n            of main model transcription\n        - early_transcription_on_silence (int, default=0): If set, the\n            system will transcribe audio faster when silence is detected.\n            Transcription will start after the specified milliseconds, so\n            keep this value lower than post_speech_silence_duration.\n            Ideally around post_speech_silence_duration minus the estimated\n            transcription time with the main model.\n            If silence lasts longer than post_speech_silence_duration, the\n            recording is stopped, and the transcription is submitted. If\n            voice activity resumes within this period, the transcription\n            is discarded. Results in faster final transcriptions to the cost\n            of additional GPU load due to some unnecessary final transcriptions.\n        - allowed_latency_limit (int, default=100): Maximal amount of chunks\n            that can be unprocessed in queue before discarding chunks.\n        - no_log_file (bool, default=False): Skips writing of debug log file.\n        - use_extended_logging (bool, default=False): Writes extensive\n            log messages for the recording worker, that processes the audio\n            chunks.\n        - faster_whisper_vad_filter (bool, default=True): If set to True,\n            the system will additionally use the VAD filter from the faster_whisper library\n            for voice activity detection. This filter is more robust against\n            background noise but requires additional GPU resources.\n        - normalize_audio (bool, default=False): If set to True, the system will\n            normalize the audio to a specific range before processing. This can\n            help improve the quality of the transcription.\n        - start_callback_in_new_thread (bool, default=False): If set to True,\n            the callback functions will be executed in a\n            new thread. This can help improve performance by allowing the\n            callback to run concurrently with other operations.\n\n        Raises:\n            Exception: Errors related to initializing transcription\n            model, wake word detection, or audio recording.\n        \"\"\"\n\n        # Instance variable initialization (fixed indentation)\n        self.language = language\n        self.compute_type = compute_type\n        self.input_device_index = input_device_index\n        self.gpu_device_index = gpu_device_index\n        self.device = device\n        self.wake_words = wake_words\n        self.wake_word_activation_delay = wake_word_activation_delay\n        self.wake_word_timeout = wake_word_timeout\n        self.wake_word_buffer_duration = wake_word_buffer_duration\n        self.ensure_sentence_starting_uppercase = ensure_sentence_starting_uppercase\n        self.ensure_sentence_ends_with_period = ensure_sentence_ends_with_period\n        self.use_microphone = mp.Value(c_bool, use_microphone)\n        self.min_gap_between_recordings = min_gap_between_recordings\n        self.min_length_of_recording = min_length_of_recording\n        self.pre_recording_buffer_duration = pre_recording_buffer_duration\n        self.post_speech_silence_duration = post_speech_silence_duration\n        self.on_recording_start = on_recording_start\n        self.on_recording_stop = on_recording_stop\n        self.on_wakeword_detected = on_wakeword_detected\n        self.on_wakeword_timeout = on_wakeword_timeout\n        self.on_vad_start = on_vad_start\n        self.on_vad_stop = on_vad_stop\n        self.on_vad_detect_start = on_vad_detect_start\n        self.on_vad_detect_stop = on_vad_detect_stop\n        self.on_turn_detection_start = on_turn_detection_start\n        self.on_turn_detection_stop = on_turn_detection_stop\n        self.on_wakeword_detection_start = on_wakeword_detection_start\n        self.on_wakeword_detection_end = on_wakeword_detection_end\n        self.on_recorded_chunk = on_recorded_chunk\n        self.on_transcription_start = on_transcription_start\n        self.enable_realtime_transcription = enable_realtime_transcription\n        self.use_main_model_for_realtime = use_main_model_for_realtime\n        self.main_model_type = model\n        self.stt_backend = stt_backend.lower() if stt_backend else \"whisper\"\n        self.download_root = download_root if download_root else None\n        self.realtime_model_type = realtime_model_type\n        self.realtime_processing_pause = realtime_processing_pause\n        self.init_realtime_after_seconds = init_realtime_after_seconds\n        self.on_realtime_transcription_update = on_realtime_transcription_update\n        self.on_realtime_transcription_stabilized = on_realtime_transcription_stabilized\n        self.debug_mode = debug_mode\n        self.handle_buffer_overflow = handle_buffer_overflow\n        self.beam_size = beam_size\n        self.beam_size_realtime = beam_size_realtime\n        self.allowed_latency_limit = allowed_latency_limit\n        self.batch_size = batch_size\n        self.realtime_batch_size = realtime_batch_size\n        self.level = level\n        self.audio_queue = mp.Queue()\n        self.buffer_size = buffer_size\n        self.sample_rate = sample_rate\n        self.recording_start_time = 0\n        self.recording_stop_time = 0\n        self.last_recording_start_time = 0\n        self.last_recording_stop_time = 0\n        self.wake_word_detect_time = 0\n        self.silero_check_time = 0\n        self.silero_working = False\n        self.speech_end_silence_start = 0\n        self.silero_sensitivity = silero_sensitivity\n        self.silero_deactivity_detection = silero_deactivity_detection\n        self.listen_start = 0\n        self.spinner = spinner\n        self.halo = None\n        self.state = \"inactive\"\n        self.wakeword_detected = False\n        self.text_storage = []\n        self.realtime_stabilized_text = \"\"\n        self.realtime_stabilized_safetext = \"\"\n        self.is_webrtc_speech_active = False\n        self.is_silero_speech_active = False\n        self.recording_thread = None\n        self.realtime_thread = None\n        self.audio_interface = None\n        self.audio = None\n        self.stream = None\n        self.start_recording_event = threading.Event()\n        self.stop_recording_event = threading.Event()\n        self.backdate_stop_seconds = 0.0\n        self.backdate_resume_seconds = 0.0\n        self.last_transcription_bytes = None\n        self.last_transcription_bytes_b64 = None\n        self.initial_prompt = initial_prompt\n        self.initial_prompt_realtime = initial_prompt_realtime\n        self.suppress_tokens = suppress_tokens\n        self.use_wake_words = wake_words or wakeword_backend in {\n            \"oww\",\n            \"openwakeword\",\n            \"openwakewords\",\n        }\n        self.detected_language = None\n        self.detected_language_probability = 0\n        self.detected_realtime_language = None\n        self.detected_realtime_language_probability = 0\n        self.transcription_lock = threading.Lock()\n        self.shutdown_lock = threading.Lock()\n        self.transcribe_count = 0\n        self.print_transcription_time = print_transcription_time\n        self.early_transcription_on_silence = early_transcription_on_silence\n        self.use_extended_logging = use_extended_logging\n        self.faster_whisper_vad_filter = faster_whisper_vad_filter\n        self.normalize_audio = normalize_audio\n        self.awaiting_speech_end = False\n        self.start_callback_in_new_thread = start_callback_in_new_thread\n        self.force_threading = force_threading\n\n        # ----------------------------------------------------------------------------\n        # Named logger configuration\n        logger.setLevel(logging.DEBUG)\n        log_format = \"RealTimeSTT: %(name)s - %(levelname)s - %(message)s\"\n        file_log_format = \"%(asctime)s.%(msecs)03d - \" + log_format\n        console_handler = logging.StreamHandler()\n        console_handler.setLevel(self.level)\n        console_handler.setFormatter(logging.Formatter(log_format))\n        logger.addHandler(console_handler)\n        if not no_log_file:\n            file_handler = logging.FileHandler(\"realtimesst.log\")\n            file_handler.setLevel(logging.DEBUG)\n            file_handler.setFormatter(\n                logging.Formatter(file_log_format, datefmt=\"%Y-%m-%d %H:%M:%S\")\n            )\n            logger.addHandler(file_handler)\n        # ----------------------------------------------------------------------------\n\n        self.is_shut_down = False\n        self.shutdown_event = mp.Event()\n\n        try:\n            # Only set the start method if it hasn't been set already\n            if mp.get_start_method(allow_none=True) is None:\n                mp.set_start_method(\"spawn\")\n        except RuntimeError as e:\n            logger.info(f\"Start method has already been set. Details: {e}\")\n\n        logger.info(\"Starting RealTimeSTT\")\n\n        if use_extended_logging:\n            logger.info(\"RealtimeSTT was called with these parameters:\")\n            for param, value in locals().items():\n                logger.info(f\"{param}: {value}\")\n\n        self.interrupt_stop_event = mp.Event()\n        self.was_interrupted = mp.Event()\n        self.main_transcription_ready_event = mp.Event()\n\n        self.parent_transcription_pipe, child_transcription_pipe = SafePipe()\n        self.parent_stdout_pipe, child_stdout_pipe = SafePipe()\n\n        # Set device for model\n        requested_device = self.device\n        self.device = (\n            \"cuda\" if self.device == \"cuda\" and torch.cuda.is_available() else \"cpu\"\n        )\n        if (\n            self.stt_backend == \"parakeet\"\n            and requested_device == \"cuda\"\n            and self.device != \"cuda\"\n        ):\n            raise RuntimeError(\n                \"GPU (CUDA) requested for Parakeet but torch reports no CUDA device. Install GPU drivers / CUDA toolkit.\"\n            )\n\n        self.transcript_process = self._start_thread(\n            target=AudioToTextRecorder._transcription_worker,\n            args=(\n                child_transcription_pipe,\n                child_stdout_pipe,\n                self.main_model_type,\n                self.download_root,\n                self.compute_type,\n                self.gpu_device_index,\n                self.device,\n                self.stt_backend,\n                self.main_transcription_ready_event,\n                self.shutdown_event,\n                self.interrupt_stop_event,\n                self.beam_size,\n                self.initial_prompt,\n                self.suppress_tokens,\n                self.batch_size,\n                self.faster_whisper_vad_filter,\n                self.normalize_audio,\n            ),\n        )\n\n        # Start audio data reading process\n        if self.use_microphone.value:\n            logger.info(\n                \"Initializing audio recording\"\n                \" (creating pyAudio input stream,\"\n                f\" sample rate: {self.sample_rate}\"\n                f\" buffer size: {self.buffer_size}\"\n            )\n            self.reader_process = self._start_thread(\n                target=AudioToTextRecorder._audio_data_worker,\n                args=(\n                    self.audio_queue,\n                    self.sample_rate,\n                    self.buffer_size,\n                    self.input_device_index,\n                    self.shutdown_event,\n                    self.interrupt_stop_event,\n                    self.use_microphone,\n                ),\n            )\n\n        # Initialize the realtime transcription model\n        if self.enable_realtime_transcription and not self.use_main_model_for_realtime:\n            try:\n                logger.info(\n                    \"Initializing faster_whisper realtime \"\n                    f\"transcription model {self.realtime_model_type}, \"\n                    f\"default device: {self.device}, \"\n                    f\"compute type: {self.compute_type}, \"\n                    f\"device index: {self.gpu_device_index}, \"\n                    f\"download root: {self.download_root}\"\n                )\n                self.realtime_model_type = faster_whisper.WhisperModel(\n                    model_size_or_path=self.realtime_model_type,\n                    device=self.device,\n                    compute_type=self.compute_type,\n                    device_index=self.gpu_device_index,\n                    download_root=self.download_root,\n                )\n                if self.realtime_batch_size > 0:\n                    self.realtime_model_type = BatchedInferencePipeline(\n                        model=self.realtime_model_type\n                    )\n\n                # Run a warm-up transcription\n                current_dir = os.path.dirname(os.path.realpath(__file__))\n                warmup_audio_path = os.path.join(current_dir, \"warmup_audio.wav\")\n                warmup_audio_data, _ = sf.read(warmup_audio_path, dtype=\"float32\")\n                segments, info = self.realtime_model_type.transcribe(\n                    warmup_audio_data, language=\"en\", beam_size=1\n                )\n                model_warmup_transcription = \" \".join(\n                    segment.text for segment in segments\n                )\n            except Exception as e:\n                logger.exception(\n                    \"Error initializing faster_whisper \"\n                    f\"realtime transcription model: {e}\"\n                )\n                raise\n\n            logger.debug(\n                \"Faster_whisper realtime speech to text \"\n                \"transcription model initialized successfully\"\n            )\n\n        # Setup wake word detection\n        if wake_words or wakeword_backend in {\n            \"oww\",\n            \"openwakeword\",\n            \"openwakewords\",\n            \"pvp\",\n            \"pvporcupine\",\n        }:\n            self.wakeword_backend = wakeword_backend\n\n            self.wake_words_list = [\n                word.strip() for word in wake_words.lower().split(\",\")\n            ]\n            self.wake_words_sensitivity = wake_words_sensitivity\n            self.wake_words_sensitivities = [\n                float(wake_words_sensitivity) for _ in range(len(self.wake_words_list))\n            ]\n\n            if wake_words and self.wakeword_backend in {\"pvp\", \"pvporcupine\"}:\n\n                try:\n                    self.porcupine = pvporcupine.create(\n                        keywords=self.wake_words_list,\n                        sensitivities=self.wake_words_sensitivities,\n                    )\n                    self.buffer_size = self.porcupine.frame_length\n                    self.sample_rate = self.porcupine.sample_rate\n\n                except Exception as e:\n                    logger.exception(\n                        \"Error initializing porcupine \"\n                        f\"wake word detection engine: {e}. \"\n                        f\"Wakewords: {self.wake_words_list}.\"\n                    )\n                    raise\n\n                logger.debug(\n                    \"Porcupine wake word detection engine initialized successfully\"\n                )\n\n            elif wake_words and self.wakeword_backend in {\n                \"oww\",\n                \"openwakeword\",\n                \"openwakewords\",\n            }:\n\n                openwakeword.utils.download_models()\n\n                try:\n                    if openwakeword_model_paths:\n                        model_paths = openwakeword_model_paths.split(\",\")\n                        self.owwModel = Model(\n                            wakeword_models=model_paths,\n                            inference_framework=openwakeword_inference_framework,\n                        )\n                        logger.info(\n                            \"Successfully loaded wakeword model(s): \"\n                            f\"{openwakeword_model_paths}\"\n                        )\n                    else:\n                        self.owwModel = Model(\n                            inference_framework=openwakeword_inference_framework\n                        )\n\n                    self.oww_n_models = len(self.owwModel.models.keys())\n                    if not self.oww_n_models:\n                        logger.error(\"No wake word models loaded.\")\n\n                    for model_key in self.owwModel.models.keys():\n                        logger.info(\n                            \"Successfully loaded openwakeword model: \" f\"{model_key}\"\n                        )\n\n                except Exception as e:\n                    logger.exception(\n                        \"Error initializing openwakeword \"\n                        f\"wake word detection engine: {e}\"\n                    )\n                    raise\n\n                logger.debug(\"Open wake word detection engine initialized successfully\")\n\n            else:\n                logger.exception(\n                    f\"Wakeword engine {self.wakeword_backend} unknown/unsupported or wake_words not specified. Please specify one of: pvporcupine, openwakeword.\"\n                )\n\n        # Setup voice activity detection model WebRTC\n        try:\n            logger.info(\n                \"Initializing WebRTC voice with \" f\"Sensitivity {webrtc_sensitivity}\"\n            )\n            self.webrtc_vad_model = webrtcvad.Vad()\n            self.webrtc_vad_model.set_mode(webrtc_sensitivity)\n\n        except Exception as e:\n            logger.exception(\n                \"Error initializing WebRTC voice \" f\"activity detection engine: {e}\"\n            )\n            raise\n\n        logger.debug(\n            \"WebRTC VAD voice activity detection \" \"engine initialized successfully\"\n        )\n\n        # Setup voice activity detection model Silero VAD\n        try:\n            self.silero_vad_model, _ = torch.hub.load(\n                repo_or_dir=\"snakers4/silero-vad\",\n                model=\"silero_vad\",\n                verbose=False,\n                onnx=silero_use_onnx,\n            )\n\n        except Exception as e:\n            logger.exception(\n                f\"Error initializing Silero VAD \"\n                f\"voice activity detection engine: {e}\"\n            )\n            raise\n\n        logger.debug(\n            \"Silero VAD voice activity detection \" \"engine initialized successfully\"\n        )\n\n        self.audio_buffer = collections.deque(\n            maxlen=int(\n                (self.sample_rate // self.buffer_size)\n                * self.pre_recording_buffer_duration\n            )\n        )\n        self.last_words_buffer = collections.deque(\n            maxlen=int((self.sample_rate // self.buffer_size) * 0.3)\n        )\n        self.frames = []\n        self.last_frames = []\n\n        # Recording control flags\n        self.is_recording = False\n        self.is_running = True\n        self.start_recording_on_voice_activity = False\n        self.stop_recording_on_voice_deactivity = False\n\n        # Start the recording worker thread\n        self.recording_thread = threading.Thread(target=self._recording_worker)\n        self.recording_thread.daemon = True\n        self.recording_thread.start()\n\n        # Start the realtime transcription worker thread\n        self.realtime_thread = threading.Thread(target=self._realtime_worker)\n        self.realtime_thread.daemon = True\n        self.realtime_thread.start()\n\n        # Wait for transcription models to start\n        logger.debug(\"Waiting for main transcription model to start\")\n        self.main_transcription_ready_event.wait()\n        logger.debug(\"Main transcription model ready\")\n\n        self.stdout_thread = threading.Thread(target=self._read_stdout)\n        self.stdout_thread.daemon = True\n        self.stdout_thread.start()\n\n        logger.debug(\"RealtimeSTT initialization completed successfully\")\n\n    def _start_thread(self, target=None, args=()):\n        \"\"\"\n        Implement a consistent threading model across the library.\n\n        This method is used to start any thread in this library. It uses the\n        standard threading. Thread for Linux and for all others uses the pytorch\n        MultiProcessing library 'Process'.\n        Args:\n            target (callable object): is the callable object to be invoked by\n              the run() method. Defaults to None, meaning nothing is called.\n            args (tuple): is a list or tuple of arguments for the target\n              invocation. Defaults to ().\n        \"\"\"\n        use_thread = (\n            getattr(self, \"force_threading\", False) or platform.system() == \"Linux\"\n        )\n        if use_thread:\n            thread = threading.Thread(target=target, args=args, daemon=True)\n            thread.start()\n            return thread\n        thread = mp.Process(target=target, args=args)\n        thread.start()\n        return thread\n\n    def _read_stdout(self):\n        while not self.shutdown_event.is_set():\n            try:\n                if self.parent_stdout_pipe.poll(0.1):\n                    logger.debug(\"Receive from stdout pipe\")\n                    message = self.parent_stdout_pipe.recv()\n                    logger.info(message)\n            except (BrokenPipeError, EOFError, OSError):\n                # The pipe probably has been closed, so we ignore the error\n                pass\n            except KeyboardInterrupt:  # handle manual interruption (Ctrl+C)\n                logger.info(\n                    \"KeyboardInterrupt in read from stdout detected, exiting...\"\n                )\n                break\n            except Exception as e:\n                logger.error(\n                    f\"Unexpected error in read from stdout: {e}\", exc_info=True\n                )\n                logger.error(traceback.format_exc())  # Log the full traceback here\n                break\n            time.sleep(0.1)\n\n    def _transcription_worker(*args, **kwargs):\n        worker = TranscriptionWorker(*args, **kwargs)\n        worker.run()\n\n    def _run_callback(self, cb, *args, **kwargs):\n        if self.start_callback_in_new_thread:\n            # Run the callback in a new thread to avoid blocking the main thread\n            threading.Thread(target=cb, args=args, kwargs=kwargs, daemon=True).start()\n        else:\n            # Run the callback in the main thread to avoid threading issues\n            cb(*args, **kwargs)\n\n    @staticmethod\n    def _audio_data_worker(\n        audio_queue,\n        target_sample_rate,\n        buffer_size,\n        input_device_index,\n        shutdown_event,\n        interrupt_stop_event,\n        use_microphone,\n    ):\n        \"\"\"\n        Worker method that handles the audio recording process.\n\n        This method runs in a separate process and is responsible for:\n        - Setting up the audio input stream for recording at the highest possible sample rate.\n        - Continuously reading audio data from the input stream, resampling if necessary,\n        preprocessing the data, and placing complete chunks in a queue.\n        - Handling errors during the recording process.\n        - Gracefully terminating the recording process when a shutdown event is set.\n\n        Args:\n            audio_queue (queue.Queue): A queue where recorded audio data is placed.\n            target_sample_rate (int): The desired sample rate for the output audio (for Silero VAD).\n            buffer_size (int): The number of samples expected by the Silero VAD model.\n            input_device_index (int): The index of the audio input device.\n            shutdown_event (threading.Event): An event that, when set, signals this worker method to terminate.\n            interrupt_stop_event (threading.Event): An event to signal keyboard interrupt.\n            use_microphone (multiprocessing.Value): A shared value indicating whether to use the microphone.\n\n        Raises:\n            Exception: If there is an error while initializing the audio recording.\n        \"\"\"\n        import pyaudio\n        import numpy as np\n        from scipy import signal\n\n        if __name__ == \"__main__\":\n            system_signal.signal(system_signal.SIGINT, system_signal.SIG_IGN)\n\n        def get_highest_sample_rate(audio_interface, device_index):\n            \"\"\"Get the highest supported sample rate for the specified device.\"\"\"\n            try:\n                device_info = audio_interface.get_device_info_by_index(device_index)\n                logger.debug(\n                    f\"Retrieving highest sample rate for device index {device_index}: {device_info}\"\n                )\n                max_rate = int(device_info[\"defaultSampleRate\"])\n\n                if \"supportedSampleRates\" in device_info:\n                    supported_rates = [\n                        int(rate) for rate in device_info[\"supportedSampleRates\"]\n                    ]\n                    if supported_rates:\n                        max_rate = max(supported_rates)\n\n                logger.debug(\n                    f\"Highest supported sample rate for device index {device_index} is {max_rate}\"\n                )\n                return max_rate\n            except Exception as e:\n                logger.warning(f\"Failed to get highest sample rate: {e}\")\n                return 48000  # Fallback to a common high sample rate\n\n        def initialize_audio_stream(audio_interface, sample_rate, chunk_size):\n            nonlocal input_device_index\n\n            def validate_device(device_index):\n                \"\"\"Validate that the device exists and is actually available for input.\"\"\"\n                try:\n                    device_info = audio_interface.get_device_info_by_index(device_index)\n                    logger.debug(\n                        f\"Validating device index {device_index} with info: {device_info}\"\n                    )\n                    if not device_info.get(\"maxInputChannels\", 0) > 0:\n                        logger.debug(\n                            \"Device has no input channels, invalid for recording.\"\n                        )\n                        return False\n\n                    # Try to actually read from the device\n                    test_stream = audio_interface.open(\n                        format=pyaudio.paInt16,\n                        channels=1,\n                        rate=target_sample_rate,\n                        input=True,\n                        frames_per_buffer=chunk_size,\n                        input_device_index=device_index,\n                        start=False,  # Don't start the stream yet\n                    )\n\n                    test_stream.start_stream()\n                    test_data = test_stream.read(\n                        chunk_size, exception_on_overflow=False\n                    )\n                    test_stream.stop_stream()\n                    test_stream.close()\n\n                    if len(test_data) == 0:\n                        logger.debug(\"Device produced no data, invalid for recording.\")\n                        return False\n\n                    logger.debug(f\"Device index {device_index} successfully validated.\")\n                    return True\n\n                except Exception as e:\n                    logger.debug(\n                        f\"Device validation failed for index {device_index}: {e}\"\n                    )\n                    return False\n\n            \"\"\"Initialize the audio stream with error handling.\"\"\"\n            while not shutdown_event.is_set():\n                try:\n                    # First, get a list of all available input devices\n                    input_devices = []\n                    device_count = audio_interface.get_device_count()\n                    logger.debug(\n                        f\"Found {device_count} total audio devices on the system.\"\n                    )\n                    for i in range(device_count):\n                        try:\n                            device_info = audio_interface.get_device_info_by_index(i)\n                            if device_info.get(\"maxInputChannels\", 0) > 0:\n                                input_devices.append(i)\n                        except Exception as e:\n                            logger.debug(\n                                f\"Could not retrieve info for device index {i}: {e}\"\n                            )\n                            continue\n\n                    logger.debug(\n                        f\"Available input devices with input channels: {input_devices}\"\n                    )\n                    if not input_devices:\n                        raise Exception(\"No input devices found\")\n\n                    # If input_device_index is None or invalid, try to find a working device\n                    if (\n                        input_device_index is None\n                        or input_device_index not in input_devices\n                    ):\n                        # First try the default device\n                        try:\n                            default_device = (\n                                audio_interface.get_default_input_device_info()\n                            )\n                            logger.debug(f\"Default device info: {default_device}\")\n                            if validate_device(default_device[\"index\"]):\n                                input_device_index = default_device[\"index\"]\n                                logger.debug(\n                                    f\"Default device {input_device_index} selected.\"\n                                )\n                        except Exception:\n                            # If default device fails, try other available input devices\n                            logger.debug(\n                                \"Default device validation failed, checking other devices...\"\n                            )\n                            for device_index in input_devices:\n                                if validate_device(device_index):\n                                    input_device_index = device_index\n                                    logger.debug(\n                                        f\"Device {input_device_index} selected.\"\n                                    )\n                                    break\n                            else:\n                                raise Exception(\"No working input devices found\")\n\n                    # Validate the selected device one final time\n                    if not validate_device(input_device_index):\n                        raise Exception(\"Selected device validation failed\")\n\n                    # If we get here, we have a validated device\n                    logger.debug(\n                        f\"Opening stream with device index {input_device_index}, \"\n                        f\"sample_rate={sample_rate}, chunk_size={chunk_size}\"\n                    )\n                    stream = audio_interface.open(\n                        format=pyaudio.paInt16,\n                        channels=1,\n                        rate=sample_rate,\n                        input=True,\n                        frames_per_buffer=chunk_size,\n                        input_device_index=input_device_index,\n                    )\n\n                    logger.info(\n                        f\"Microphone connected and validated (device index: {input_device_index}, \"\n                        f\"sample rate: {sample_rate}, chunk size: {chunk_size})\"\n                    )\n                    return stream\n\n                except Exception as e:\n                    logger.error(\n                        f\"Microphone connection failed: {e}. Retrying...\", exc_info=True\n                    )\n                    input_device_index = None\n                    time.sleep(3)  # Wait before retrying\n                    continue\n\n        def preprocess_audio(chunk, original_sample_rate, target_sample_rate):\n            \"\"\"Preprocess audio chunk similar to feed_audio method.\"\"\"\n            if isinstance(chunk, np.ndarray):\n                # Handle stereo to mono conversion if necessary\n                if chunk.ndim == 2:\n                    chunk = np.mean(chunk, axis=1)\n\n                # Resample to target_sample_rate if necessary\n                if original_sample_rate != target_sample_rate:\n                    logger.debug(\n                        f\"Resampling from {original_sample_rate} Hz to {target_sample_rate} Hz.\"\n                    )\n                    num_samples = int(\n                        len(chunk) * target_sample_rate / original_sample_rate\n                    )\n                    chunk = signal.resample(chunk, num_samples)\n\n                chunk = chunk.astype(np.int16)\n            else:\n                # If chunk is bytes, convert to numpy array\n                chunk = np.frombuffer(chunk, dtype=np.int16)\n\n                # Resample if necessary\n                if original_sample_rate != target_sample_rate:\n                    logger.debug(\n                        f\"Resampling from {original_sample_rate} Hz to {target_sample_rate} Hz.\"\n                    )\n                    num_samples = int(\n                        len(chunk) * target_sample_rate / original_sample_rate\n                    )\n                    chunk = signal.resample(chunk, num_samples)\n                    chunk = chunk.astype(np.int16)\n\n            return chunk.tobytes()\n\n        audio_interface = None\n        stream = None\n        device_sample_rate = None\n        chunk_size = 1024  # Increased chunk size for better performance\n\n        def setup_audio():\n            nonlocal audio_interface, stream, device_sample_rate, input_device_index\n            try:\n                if audio_interface is None:\n                    logger.debug(\"Creating PyAudio interface...\")\n                    audio_interface = pyaudio.PyAudio()\n\n                if input_device_index is None:\n                    try:\n                        default_device = audio_interface.get_default_input_device_info()\n                        input_device_index = default_device[\"index\"]\n                        logger.debug(\n                            f\"No device index supplied; using default device {input_device_index}\"\n                        )\n                    except OSError as e:\n                        logger.debug(f\"Default device retrieval failed: {e}\")\n                        input_device_index = None\n\n                # We'll try 16000 Hz first, then the highest rate we detect, then fallback if needed\n                sample_rates_to_try = [16000]\n                if input_device_index is not None:\n                    highest_rate = get_highest_sample_rate(\n                        audio_interface, input_device_index\n                    )\n                    if highest_rate != 16000:\n                        sample_rates_to_try.append(highest_rate)\n                else:\n                    sample_rates_to_try.append(48000)\n\n                logger.debug(\n                    f\"Sample rates to try for device {input_device_index}: {sample_rates_to_try}\"\n                )\n\n                for rate in sample_rates_to_try:\n                    try:\n                        device_sample_rate = rate\n                        logger.debug(\n                            f\"Attempting to initialize audio stream at {device_sample_rate} Hz.\"\n                        )\n                        stream = initialize_audio_stream(\n                            audio_interface, device_sample_rate, chunk_size\n                        )\n                        if stream is not None:\n                            logger.debug(\n                                f\"Audio recording initialized successfully at {device_sample_rate} Hz, \"\n                                f\"reading {chunk_size} frames at a time\"\n                            )\n                            return True\n                    except Exception as e:\n                        logger.warning(\n                            f\"Failed to initialize audio stream at {device_sample_rate} Hz: {e}\"\n                        )\n                        continue\n\n                # If we reach here, none of the sample rates worked\n                raise Exception(\n                    \"Failed to initialize audio stream with all sample rates.\"\n                )\n\n            except Exception as e:\n                logger.exception(f\"Error initializing pyaudio audio recording: {e}\")\n                if audio_interface:\n                    audio_interface.terminate()\n                return False\n\n        logger.debug(\n            f\"Starting audio data worker with target_sample_rate={target_sample_rate}, \"\n            f\"buffer_size={buffer_size}, input_device_index={input_device_index}\"\n        )\n\n        if not setup_audio():\n            raise Exception(\"Failed to set up audio recording.\")\n\n        buffer = bytearray()\n        silero_buffer_size = 2 * buffer_size  # Silero complains if too short\n\n        time_since_last_buffer_message = 0\n\n        try:\n            while not shutdown_event.is_set():\n                try:\n                    data = stream.read(chunk_size, exception_on_overflow=False)\n\n                    if use_microphone.value:\n                        processed_data = preprocess_audio(\n                            data, device_sample_rate, target_sample_rate\n                        )\n                        buffer += processed_data\n\n                        # Check if the buffer has reached or exceeded the silero_buffer_size\n                        while len(buffer) >= silero_buffer_size:\n                            # Extract silero_buffer_size amount of data from the buffer\n                            to_process = buffer[:silero_buffer_size]\n                            buffer = buffer[silero_buffer_size:]\n\n                            # Feed the extracted data to the audio_queue\n                            if time_since_last_buffer_message:\n                                time_passed = (\n                                    time.time() - time_since_last_buffer_message\n                                )\n                                if time_passed > 1:\n                                    logger.debug(\n                                        \"_audio_data_worker writing audio data into queue.\"\n                                    )\n                                    time_since_last_buffer_message = time.time()\n                            else:\n                                time_since_last_buffer_message = time.time()\n\n                            audio_queue.put(to_process)\n\n                except OSError as e:\n                    if e.errno == pyaudio.paInputOverflowed:\n                        logger.warning(\"Input overflowed. Frame dropped.\")\n                    else:\n                        logger.error(f\"OSError during recording: {e}\", exc_info=True)\n                        # Attempt to reinitialize the stream\n                        logger.error(\"Attempting to reinitialize the audio stream...\")\n\n                        try:\n                            if stream:\n                                stream.stop_stream()\n                                stream.close()\n                        except Exception:\n                            pass\n\n                        time.sleep(1)\n                        if not setup_audio():\n                            logger.error(\n                                \"Failed to reinitialize audio stream. Exiting.\"\n                            )\n                            break\n                        else:\n                            logger.error(\"Audio stream reinitialized successfully.\")\n                    continue\n\n                except Exception as e:\n                    logger.error(f\"Unknown error during recording: {e}\")\n                    tb_str = traceback.format_exc()\n                    logger.error(f\"Traceback: {tb_str}\")\n                    logger.error(f\"Error: {e}\")\n                    # Attempt to reinitialize the stream\n                    logger.info(\"Attempting to reinitialize the audio stream...\")\n                    try:\n                        if stream:\n                            stream.stop_stream()\n                            stream.close()\n                    except Exception:\n                        pass\n\n                    time.sleep(1)\n                    if not setup_audio():\n                        logger.error(\"Failed to reinitialize audio stream. Exiting.\")\n                        break\n                    else:\n                        logger.info(\"Audio stream reinitialized successfully.\")\n                    continue\n\n        except KeyboardInterrupt:\n            interrupt_stop_event.set()\n            logger.debug(\"Audio data worker process finished due to KeyboardInterrupt\")\n        finally:\n            # After recording stops, feed any remaining audio data\n            if buffer:\n                audio_queue.put(bytes(buffer))\n\n            try:\n                if stream:\n                    stream.stop_stream()\n                    stream.close()\n            except Exception:\n                pass\n            if audio_interface:\n                audio_interface.terminate()\n\n    def wakeup(self):\n        \"\"\"\n        If in wake work modus, wake up as if a wake word was spoken.\n        \"\"\"\n        self.listen_start = time.time()\n\n    def abort(self):\n        state = self.state\n        self.start_recording_on_voice_activity = False\n        self.stop_recording_on_voice_deactivity = False\n        self.interrupt_stop_event.set()\n        if self.state != \"inactive\":  # if inactive, was_interrupted will never be set\n            self.was_interrupted.wait()\n            self._set_state(\"transcribing\")\n        self.was_interrupted.clear()\n        if self.is_recording:  # if recording, make sure to stop the recorder\n            self.stop()\n\n    def wait_audio(self):\n        \"\"\"\n        Waits for the start and completion of the audio recording process.\n\n        This method is responsible for:\n        - Waiting for voice activity to begin recording if not yet started.\n        - Waiting for voice inactivity to complete the recording.\n        - Setting the audio buffer from the recorded frames.\n        - Resetting recording-related attributes.\n\n        Side effects:\n        - Updates the state of the instance.\n        - Modifies the audio attribute to contain the processed audio data.\n        \"\"\"\n\n        try:\n            logger.info(\"Setting listen time\")\n            if self.listen_start == 0:\n                self.listen_start = time.time()\n\n            # If not yet started recording, wait for voice activity to initiate.\n            if not self.is_recording and not self.frames:\n                self._set_state(\"listening\")\n                self.start_recording_on_voice_activity = True\n\n                # Wait until recording starts\n                logger.debug(\"Waiting for recording start\")\n                while not self.interrupt_stop_event.is_set():\n                    if self.start_recording_event.wait(timeout=0.02):\n                        break\n\n            # If recording is ongoing, wait for voice inactivity\n            # to finish recording.\n            if self.is_recording:\n                self.stop_recording_on_voice_deactivity = True\n\n                # Wait until recording stops\n                logger.debug(\"Waiting for recording stop\")\n                while not self.interrupt_stop_event.is_set():\n                    if self.stop_recording_event.wait(timeout=0.02):\n                        break\n\n            frames = self.frames\n            if len(frames) == 0:\n                frames = self.last_frames\n\n            # Calculate samples needed for backdating resume\n            samples_to_keep = int(self.sample_rate * self.backdate_resume_seconds)\n\n            # First convert all current frames to audio array\n            full_audio_array = np.frombuffer(b\"\".join(frames), dtype=np.int16)\n            full_audio = full_audio_array.astype(np.float32) / INT16_MAX_ABS_VALUE\n\n            # Calculate how many samples we need to keep for backdating resume\n            if samples_to_keep > 0:\n                samples_to_keep = min(samples_to_keep, len(full_audio))\n                # Keep the last N samples for backdating resume\n                frames_to_read_audio = full_audio[-samples_to_keep:]\n\n                # Convert the audio back to int16 bytes for frames\n                frames_to_read_int16 = (\n                    frames_to_read_audio * INT16_MAX_ABS_VALUE\n                ).astype(np.int16)\n                frame_bytes = frames_to_read_int16.tobytes()\n\n                # Split into appropriate frame sizes (assuming standard frame size)\n                FRAME_SIZE = 2048  # Typical frame size\n                frames_to_read = []\n                for i in range(0, len(frame_bytes), FRAME_SIZE):\n                    frame = frame_bytes[i : i + FRAME_SIZE]\n                    if frame:  # Only add non-empty frames\n                        frames_to_read.append(frame)\n            else:\n                frames_to_read = []\n\n            # Process backdate stop seconds\n            samples_to_remove = int(self.sample_rate * self.backdate_stop_seconds)\n\n            if samples_to_remove > 0:\n                if samples_to_remove < len(full_audio):\n                    self.audio = full_audio[:-samples_to_remove]\n                    logger.debug(\n                        f\"Removed {samples_to_remove} samples \"\n                        f\"({samples_to_remove/self.sample_rate:.3f}s) from end of audio\"\n                    )\n                else:\n                    self.audio = np.array([], dtype=np.float32)\n                    logger.debug(\"Cleared audio (samples_to_remove >= audio length)\")\n            else:\n                self.audio = full_audio\n                logger.debug(\n                    f\"No samples removed, final audio length: {len(self.audio)}\"\n                )\n\n            self.frames.clear()\n            self.last_frames.clear()\n            self.frames.extend(frames_to_read)\n\n            # Reset backdating parameters\n            self.backdate_stop_seconds = 0.0\n            self.backdate_resume_seconds = 0.0\n\n            self.listen_start = 0\n\n            self._set_state(\"inactive\")\n\n        except KeyboardInterrupt:\n            logger.info(\"KeyboardInterrupt in wait_audio, shutting down\")\n            self.shutdown()\n            raise  # Re-raise the exception after cleanup\n\n    def perform_final_transcription(self, audio_bytes=None, use_prompt=True):\n        start_time = 0\n        with self.transcription_lock:\n            if audio_bytes is None:\n                audio_bytes = copy.deepcopy(self.audio)\n\n            if audio_bytes is None or len(audio_bytes) == 0:\n                print(\"No audio data available for transcription\")\n                # logger.info(\"No audio data available for transcription\")\n                return \"\"\n\n            try:\n                if self.transcribe_count == 0:\n                    logger.debug(\n                        \"Adding transcription request, no early transcription started\"\n                    )\n                    start_time = time.time()  # Start timing\n                    self.parent_transcription_pipe.send(\n                        (audio_bytes, self.language, use_prompt)\n                    )\n                    self.transcribe_count += 1\n\n                while self.transcribe_count > 0:\n                    logger.debug(\n                        f\"Receive from parent_transcription_pipe after sendiung transcription request, transcribe_count: {self.transcribe_count}\"\n                    )\n                    if not self.parent_transcription_pipe.poll(\n                        0.1\n                    ):  # check if transcription done\n                        if self.interrupt_stop_event.is_set():  # check if interrupted\n                            self.was_interrupted.set()\n                            self._set_state(\"inactive\")\n                            return \"\"  # return empty string if interrupted\n                        continue\n                    status, result = self.parent_transcription_pipe.recv()\n                    self.transcribe_count -= 1\n\n                self.allowed_to_early_transcribe = True\n                self._set_state(\"inactive\")\n                if status == \"success\":\n                    segments, info = result\n                    if isinstance(segments, str):\n                        segments = [types.SimpleNamespace(text=segments)]\n                    elif isinstance(segments, list):\n                        normalized = []\n                        for s in segments:\n                            if hasattr(s, \"text\"):\n                                normalized.append(s)\n                            else:\n                                normalized.append(types.SimpleNamespace(text=str(s)))\n                        segments = normalized\n                    else:\n                        segments = [types.SimpleNamespace(text=str(segments))]\n\n                    self.detected_language = getattr(info, \"language\", None)\n                    self.detected_language_probability = getattr(\n                        info, \"language_probability\", 0\n                    )\n                    self.last_transcription_bytes = copy.deepcopy(audio_bytes)\n                    self.last_transcription_bytes_b64 = base64.b64encode(\n                        self.last_transcription_bytes.tobytes()\n                    ).decode(\"utf-8\")\n                    raw_text = (\n                        \" \".join(s.text for s in segments).strip() if segments else \"\"\n                    )\n                    transcription = self._preprocess_output(raw_text)\n                    end_time = time.time()  # End timing\n                    transcription_time = end_time - start_time\n\n                    if start_time:\n                        if self.print_transcription_time:\n                            print(\n                                f\"Model {self.main_model_type} completed transcription in {transcription_time:.2f} seconds\"\n                            )\n                        else:\n                            logger.debug(\n                                f\"Model {self.main_model_type} completed transcription in {transcription_time:.2f} seconds\"\n                            )\n                    return (\n                        \"\" if self.interrupt_stop_event.is_set() else transcription\n                    )  # if interrupted return empty string\n                else:\n                    logger.error(f\"Transcription error: {result}\")\n                    raise Exception(result)\n            except Exception as e:\n                logger.error(f\"Error during transcription: {str(e)}\", exc_info=True)\n                raise e\n\n    def transcribe(self):\n        \"\"\"\n        Transcribes audio captured by this class instance using the\n        `faster_whisper` model.\n\n        Automatically starts recording upon voice activity if not manually\n          started using `recorder.start()`.\n        Automatically stops recording upon voice deactivity if not manually\n          stopped with `recorder.stop()`.\n        Processes the recorded audio to generate transcription.\n\n        Args:\n            on_transcription_finished (callable, optional): Callback function\n              to be executed when transcription is ready.\n            If provided, transcription will be performed asynchronously,\n              and the callback will receive the transcription as its argument.\n              If omitted, the transcription will be performed synchronously,\n              and the result will be returned.\n\n        Returns (if no callback is set):\n            str: The transcription of the recorded audio.\n\n        Raises:\n            Exception: If there is an error during the transcription process.\n        \"\"\"\n        audio_copy = copy.deepcopy(self.audio)\n        self._set_state(\"transcribing\")\n        if self.on_transcription_start:\n            abort_value = self.on_transcription_start(audio_copy)\n            if not abort_value:\n                return self.perform_final_transcription(audio_copy)\n            return None\n        else:\n            return self.perform_final_transcription(audio_copy)\n\n    def _process_wakeword(self, data):\n        \"\"\"\n        Processes audio data to detect wake words.\n        \"\"\"\n        if self.wakeword_backend in {\"pvp\", \"pvporcupine\"}:\n            pcm = struct.unpack_from(\"h\" * self.buffer_size, data)\n            porcupine_index = self.porcupine.process(pcm)\n            if self.debug_mode:\n                logger.info(f\"wake words porcupine_index: {porcupine_index}\")\n            return porcupine_index\n\n        elif self.wakeword_backend in {\"oww\", \"openwakeword\", \"openwakewords\"}:\n            pcm = np.frombuffer(data, dtype=np.int16)\n            prediction = self.owwModel.predict(pcm)\n            max_score = -1\n            max_index = -1\n            wake_words_in_prediction = len(self.owwModel.prediction_buffer.keys())\n            self.wake_words_sensitivities\n            if wake_words_in_prediction:\n                for idx, mdl in enumerate(self.owwModel.prediction_buffer.keys()):\n                    scores = list(self.owwModel.prediction_buffer[mdl])\n                    if (\n                        scores[-1] >= self.wake_words_sensitivity\n                        and scores[-1] > max_score\n                    ):\n                        max_score = scores[-1]\n                        max_index = idx\n                if self.debug_mode:\n                    logger.info(\n                        f\"wake words oww max_index, max_score: {max_index} {max_score}\"\n                    )\n                return max_index\n            else:\n                if self.debug_mode:\n                    logger.info(f\"wake words oww_index: -1\")\n                return -1\n\n        if self.debug_mode:\n            logger.info(\"wake words no match\")\n\n        return -1\n\n    def text(\n        self,\n        on_transcription_finished=None,\n    ):\n        \"\"\"\n        Transcribes audio captured by this class instance\n        using the `faster_whisper` model.\n\n        - Automatically starts recording upon voice activity if not manually\n          started using `recorder.start()`.\n        - Automatically stops recording upon voice deactivity if not manually\n          stopped with `recorder.stop()`.\n        - Processes the recorded audio to generate transcription.\n\n        Args:\n            on_transcription_finished (callable, optional): Callback function\n              to be executed when transcription is ready.\n            If provided, transcription will be performed asynchronously, and\n              the callback will receive the transcription as its argument.\n              If omitted, the transcription will be performed synchronously,\n              and the result will be returned.\n\n        Returns (if not callback is set):\n            str: The transcription of the recorded audio\n        \"\"\"\n        self.interrupt_stop_event.clear()\n        self.was_interrupted.clear()\n        try:\n            self.wait_audio()\n        except KeyboardInterrupt:\n            logger.info(\"KeyboardInterrupt in text() method\")\n            self.shutdown()\n            raise  # Re-raise the exception after cleanup\n\n        if self.is_shut_down or self.interrupt_stop_event.is_set():\n            if self.interrupt_stop_event.is_set():\n                self.was_interrupted.set()\n            return \"\"\n\n        if on_transcription_finished:\n            threading.Thread(\n                target=on_transcription_finished, args=(self.transcribe(),)\n            ).start()\n        else:\n            return self.transcribe()\n\n    def format_number(self, num):\n        # Convert the number to a string\n        num_str = f\"{num:.10f}\"  # Ensure precision is sufficient\n        # Split the number into integer and decimal parts\n        integer_part, decimal_part = num_str.split(\".\")\n        # Take the last two digits of the integer part and the first two digits of the decimal part\n        result = f\"{integer_part[-2:]}.{decimal_part[:2]}\"\n        return result\n\n    def start(self, frames=None):\n        \"\"\"\n        Starts recording audio directly without waiting for voice activity.\n        \"\"\"\n\n        # Ensure there's a minimum interval\n        # between stopping and starting recording\n        if time.time() - self.recording_stop_time < self.min_gap_between_recordings:\n            logger.info(\"Attempted to start recording \" \"too soon after stopping.\")\n            return self\n\n        logger.info(\"recording started\")\n        self._set_state(\"recording\")\n        self.text_storage = []\n        self.realtime_stabilized_text = \"\"\n        self.realtime_stabilized_safetext = \"\"\n        self.wakeword_detected = False\n        self.wake_word_detect_time = 0\n        self.frames = []\n        if frames:\n            self.frames = frames\n        self.is_recording = True\n\n        self.recording_start_time = time.time()\n        self.is_silero_speech_active = False\n        self.is_webrtc_speech_active = False\n        self.stop_recording_event.clear()\n        self.start_recording_event.set()\n\n        if self.on_recording_start:\n            self._run_callback(self.on_recording_start)\n\n        return self\n\n    def stop(\n        self,\n        backdate_stop_seconds: float = 0.0,\n        backdate_resume_seconds: float = 0.0,\n    ):\n        \"\"\"\n        Stops recording audio.\n\n        Args:\n        - backdate_stop_seconds (float, default=\"0.0\"): Specifies the number of\n            seconds to backdate the stop time. This is useful when the stop\n            command is issued after the actual stop time.\n        - backdate_resume_seconds (float, default=\"0.0\"): Specifies the number\n            of seconds to backdate the time relistening is initiated.\n        \"\"\"\n\n        # Ensure there's a minimum interval\n        # between starting and stopping recording\n        if time.time() - self.recording_start_time < self.min_length_of_recording:\n            logger.info(\"Attempted to stop recording \" \"too soon after starting.\")\n            return self\n\n        logger.info(\"recording stopped\")\n        self.last_frames = copy.deepcopy(self.frames)\n        self.backdate_stop_seconds = backdate_stop_seconds\n        self.backdate_resume_seconds = backdate_resume_seconds\n        self.is_recording = False\n        self.recording_stop_time = time.time()\n        self.is_silero_speech_active = False\n        self.is_webrtc_speech_active = False\n        self.silero_check_time = 0\n        self.start_recording_event.clear()\n        self.stop_recording_event.set()\n\n        self.last_recording_start_time = self.recording_start_time\n        self.last_recording_stop_time = self.recording_stop_time\n\n        if self.on_recording_stop:\n            self._run_callback(self.on_recording_stop)\n\n        return self\n\n    def listen(self):\n        \"\"\"\n        Puts recorder in immediate \"listen\" state.\n        This is the state after a wake word detection, for example.\n        The recorder now \"listens\" for voice activation.\n        Once voice is detected we enter \"recording\" state.\n        \"\"\"\n        self.listen_start = time.time()\n        self._set_state(\"listening\")\n        self.start_recording_on_voice_activity = True\n\n    def feed_audio(self, chunk, original_sample_rate=16000):\n        \"\"\"\n        Feed an audio chunk into the processing pipeline. Chunks are\n        accumulated until the buffer size is reached, and then the accumulated\n        data is fed into the audio_queue.\n        \"\"\"\n        # Check if the buffer attribute exists, if not, initialize it\n        if not hasattr(self, \"buffer\"):\n            self.buffer = bytearray()\n\n        # Check if input is a NumPy array\n        if isinstance(chunk, np.ndarray):\n            # Handle stereo to mono conversion if necessary\n            if chunk.ndim == 2:\n                chunk = np.mean(chunk, axis=1)\n\n            # Resample to 16000 Hz if necessary\n            if original_sample_rate != 16000:\n                num_samples = int(len(chunk) * 16000 / original_sample_rate)\n                chunk = resample(chunk, num_samples)\n\n            # Ensure data type is int16\n            chunk = chunk.astype(np.int16)\n\n            # Convert the NumPy array to bytes\n            chunk = chunk.tobytes()\n\n        # Append the chunk to the buffer\n        self.buffer += chunk\n        buf_size = 2 * self.buffer_size  # silero complains if too short\n\n        # Check if the buffer has reached or exceeded the buffer_size\n        while len(self.buffer) >= buf_size:\n            # Extract self.buffer_size amount of data from the buffer\n            to_process = self.buffer[:buf_size]\n            self.buffer = self.buffer[buf_size:]\n\n            # Feed the extracted data to the audio_queue\n            self.audio_queue.put(to_process)\n\n    def set_microphone(self, microphone_on=True):\n        \"\"\"\n        Set the microphone on or off.\n        \"\"\"\n        logger.info(\"Setting microphone to: \" + str(microphone_on))\n        self.use_microphone.value = microphone_on\n\n    def shutdown(self):\n        \"\"\"\n        Safely shuts down the audio recording by stopping the\n        recording worker and closing the audio stream.\n        \"\"\"\n\n        with self.shutdown_lock:\n            if self.is_shut_down:\n                return\n\n            print(\"\\033[91mRealtimeSTT shutting down\\033[0m\")\n\n            # Force wait_audio() and text() to exit\n            self.is_shut_down = True\n            self.start_recording_event.set()\n            self.stop_recording_event.set()\n\n            self.shutdown_event.set()\n            self.is_recording = False\n            self.is_running = False\n\n            logger.debug(\"Finishing recording thread\")\n            if self.recording_thread:\n                self.recording_thread.join()\n\n            logger.debug(\"Terminating reader process\")\n\n            # Give it some time to finish the loop and cleanup.\n            if self.use_microphone.value:\n                self.reader_process.join(timeout=10)\n\n                if self.reader_process.is_alive():\n                    logger.warning(\n                        \"Reader process did not terminate \"\n                        \"in time. Terminating forcefully.\"\n                    )\n                    self.reader_process.terminate()\n\n            logger.debug(\"Terminating transcription process\")\n            self.transcript_process.join(timeout=10)\n\n            if self.transcript_process.is_alive():\n                logger.warning(\n                    \"Transcript process did not terminate \"\n                    \"in time. Terminating forcefully.\"\n                )\n                self.transcript_process.terminate()\n\n            self.parent_transcription_pipe.close()\n\n            logger.debug(\"Finishing realtime thread\")\n            if self.realtime_thread:\n                self.realtime_thread.join()\n\n            if self.enable_realtime_transcription:\n                if self.realtime_model_type:\n                    del self.realtime_model_type\n                    self.realtime_model_type = None\n            gc.collect()\n\n    def _recording_worker(self):\n        \"\"\"\n        The main worker method which constantly monitors the audio\n        input for voice activity and accordingly starts/stops the recording.\n        \"\"\"\n\n        if self.use_extended_logging:\n            logger.debug(\"Debug: Entering try block\")\n\n        last_inner_try_time = 0\n        try:\n            if self.use_extended_logging:\n                logger.debug(\"Debug: Initializing variables\")\n            time_since_last_buffer_message = 0\n            was_recording = False\n            delay_was_passed = False\n            wakeword_detected_time = None\n            wakeword_samples_to_remove = None\n            self.allowed_to_early_transcribe = True\n\n            if self.use_extended_logging:\n                logger.debug(\"Debug: Starting main loop\")\n            # Continuously monitor audio for voice activity\n            while self.is_running:\n\n                # if self.use_extended_logging:\n                #     logger.debug('Debug: Entering inner try block')\n                if last_inner_try_time:\n                    last_processing_time = time.time() - last_inner_try_time\n                    if last_processing_time > 0.1:\n                        if self.use_extended_logging:\n                            logger.warning(\"### WARNING: PROCESSING TOOK TOO LONG\")\n                last_inner_try_time = time.time()\n                try:\n                    # if self.use_extended_logging:\n                    #     logger.debug('Debug: Trying to get data from audio queue')\n                    try:\n                        data = self.audio_queue.get(timeout=0.01)\n                        self.last_words_buffer.append(data)\n                    except queue.Empty:\n                        # if self.use_extended_logging:\n                        #     logger.debug('Debug: Queue is empty, checking if still running')\n                        if not self.is_running:\n                            if self.use_extended_logging:\n                                logger.debug(\"Debug: Not running, breaking loop\")\n                            break\n                        # if self.use_extended_logging:\n                        #     logger.debug('Debug: Continuing to next iteration')\n                        continue\n\n                    if self.use_extended_logging:\n                        logger.debug(\"Debug: Checking for on_recorded_chunk callback\")\n                    if self.on_recorded_chunk:\n                        if self.use_extended_logging:\n                            logger.debug(\"Debug: Calling on_recorded_chunk\")\n                        self._run_callback(self.on_recorded_chunk, data)\n\n                    if self.use_extended_logging:\n                        logger.debug(\n                            \"Debug: Checking if handle_buffer_overflow is True\"\n                        )\n                    if self.handle_buffer_overflow:\n                        if self.use_extended_logging:\n                            logger.debug(\"Debug: Handling buffer overflow\")\n                        # Handle queue overflow\n                        if self.audio_queue.qsize() > self.allowed_latency_limit:\n                            if self.use_extended_logging:\n                                logger.debug(\n                                    \"Debug: Queue size exceeds limit, logging warnings\"\n                                )\n                            logger.warning(\n                                \"Audio queue size exceeds \"\n                                \"latency limit. Current size: \"\n                                f\"{self.audio_queue.qsize()}. \"\n                                \"Discarding old audio chunks.\"\n                            )\n\n                        if self.use_extended_logging:\n                            logger.debug(\"Debug: Discarding old chunks if necessary\")\n                        while self.audio_queue.qsize() > self.allowed_latency_limit:\n\n                            data = self.audio_queue.get()\n\n                except BrokenPipeError:\n                    logger.error(\"BrokenPipeError _recording_worker\", exc_info=True)\n                    self.is_running = False\n                    break\n\n                if self.use_extended_logging:\n                    logger.debug(\"Debug: Updating time_since_last_buffer_message\")\n                # Feed the extracted data to the audio_queue\n                if time_since_last_buffer_message:\n                    time_passed = time.time() - time_since_last_buffer_message\n                    if time_passed > 1:\n                        if self.use_extended_logging:\n                            logger.debug(\"_recording_worker processing audio data\")\n                        time_since_last_buffer_message = time.time()\n                else:\n                    time_since_last_buffer_message = time.time()\n\n                if self.use_extended_logging:\n                    logger.debug(\"Debug: Initializing failed_stop_attempt\")\n                failed_stop_attempt = False\n\n                if self.use_extended_logging:\n                    logger.debug(\"Debug: Checking if not recording\")\n                if not self.is_recording:\n                    if self.use_extended_logging:\n                        logger.debug(\"Debug: Handling not recording state\")\n                    # Handle not recording state\n                    time_since_listen_start = (\n                        time.time() - self.listen_start if self.listen_start else 0\n                    )\n\n                    wake_word_activation_delay_passed = (\n                        time_since_listen_start > self.wake_word_activation_delay\n                    )\n\n                    if self.use_extended_logging:\n                        logger.debug(\"Debug: Handling wake-word timeout callback\")\n                    # Handle wake-word timeout callback\n                    if wake_word_activation_delay_passed and not delay_was_passed:\n\n                        if self.use_wake_words and self.wake_word_activation_delay:\n                            if self.on_wakeword_timeout:\n                                if self.use_extended_logging:\n                                    logger.debug(\"Debug: Calling on_wakeword_timeout\")\n                                self._run_callback(self.on_wakeword_timeout)\n                    delay_was_passed = wake_word_activation_delay_passed\n\n                    if self.use_extended_logging:\n                        logger.debug(\"Debug: Setting state and spinner text\")\n                    # Set state and spinner text\n                    if not self.recording_stop_time:\n                        if (\n                            self.use_wake_words\n                            and wake_word_activation_delay_passed\n                            and not self.wakeword_detected\n                        ):\n                            if self.use_extended_logging:\n                                logger.debug('Debug: Setting state to \"wakeword\"')\n                            self._set_state(\"wakeword\")\n                        else:\n                            if self.listen_start:\n                                if self.use_extended_logging:\n                                    logger.debug('Debug: Setting state to \"listening\"')\n                                self._set_state(\"listening\")\n                            else:\n                                if self.use_extended_logging:\n                                    logger.debug('Debug: Setting state to \"inactive\"')\n                                self._set_state(\"inactive\")\n\n                    if self.use_extended_logging:\n                        logger.debug(\"Debug: Checking wake word conditions\")\n                    if self.use_wake_words and wake_word_activation_delay_passed:\n                        try:\n                            if self.use_extended_logging:\n                                logger.debug(\"Debug: Processing wakeword\")\n                            wakeword_index = self._process_wakeword(data)\n\n                        except struct.error:\n                            logger.error(\n                                \"Error unpacking audio data \"\n                                \"for wake word processing.\",\n                                exc_info=True,\n                            )\n                            continue\n\n                        except Exception as e:\n                            logger.error(\n                                f\"Wake word processing error: {e}\", exc_info=True\n                            )\n                            continue\n\n                        if self.use_extended_logging:\n                            logger.debug(\"Debug: Checking if wake word detected\")\n                        # If a wake word is detected\n                        if wakeword_index >= 0:\n                            if self.use_extended_logging:\n                                logger.debug(\n                                    \"Debug: Wake word detected, updating variables\"\n                                )\n                            self.wake_word_detect_time = time.time()\n                            wakeword_detected_time = time.time()\n                            wakeword_samples_to_remove = int(\n                                self.sample_rate * self.wake_word_buffer_duration\n                            )\n                            self.wakeword_detected = True\n                            if self.on_wakeword_detected:\n                                if self.use_extended_logging:\n                                    logger.debug(\"Debug: Calling on_wakeword_detected\")\n                                self._run_callback(self.on_wakeword_detected)\n\n                    if self.use_extended_logging:\n                        logger.debug(\"Debug: Checking voice activity conditions\")\n                    # Check for voice activity to\n                    # trigger the start of recording\n                    if (\n                        (\n                            not self.use_wake_words\n                            or not wake_word_activation_delay_passed\n                        )\n                        and self.start_recording_on_voice_activity\n                    ) or self.wakeword_detected:\n\n                        if self.use_extended_logging:\n                            logger.debug(\"Debug: Checking if voice is active\")\n\n                        if self._is_voice_active():\n\n                            if self.on_vad_start:\n                                self._run_callback(self.on_vad_start)\n\n                            if self.use_extended_logging:\n                                logger.debug(\"Debug: Voice activity detected\")\n                            logger.info(\"voice activity detected\")\n\n                            if self.use_extended_logging:\n                                logger.debug(\"Debug: Starting recording\")\n                            self.start()\n\n                            self.start_recording_on_voice_activity = False\n\n                            if self.use_extended_logging:\n                                logger.debug(\"Debug: Adding buffered audio to frames\")\n                            # Add the buffered audio\n                            # to the recording frames\n                            self.frames.extend(list(self.audio_buffer))\n                            self.audio_buffer.clear()\n\n                            if self.use_extended_logging:\n                                logger.debug(\"Debug: Resetting Silero VAD model states\")\n                            self.silero_vad_model.reset_states()\n                        else:\n                            if self.use_extended_logging:\n                                logger.debug(\"Debug: Checking voice activity\")\n                            data_copy = data[:]\n                            self._check_voice_activity(data_copy)\n\n                    if self.use_extended_logging:\n                        logger.debug(\"Debug: Resetting speech_end_silence_start\")\n\n                    if self.speech_end_silence_start != 0:\n                        self.speech_end_silence_start = 0\n                        if self.on_turn_detection_stop:\n                            if self.use_extended_logging:\n                                logger.debug(\"Debug: Calling on_turn_detection_stop\")\n                            self._run_callback(self.on_turn_detection_stop)\n\n                else:\n                    if self.use_extended_logging:\n                        logger.debug(\"Debug: Handling recording state\")\n                    # If we are currently recording\n                    if wakeword_samples_to_remove and wakeword_samples_to_remove > 0:\n                        if self.use_extended_logging:\n                            logger.debug(\"Debug: Removing wakeword samples\")\n                        # Remove samples from the beginning of self.frames\n                        samples_removed = 0\n                        while wakeword_samples_to_remove > 0 and self.frames:\n                            frame = self.frames[0]\n                            frame_samples = len(frame) // 2  # Assuming 16-bit audio\n                            if wakeword_samples_to_remove >= frame_samples:\n                                self.frames.pop(0)\n                                samples_removed += frame_samples\n                                wakeword_samples_to_remove -= frame_samples\n                            else:\n                                self.frames[0] = frame[wakeword_samples_to_remove * 2 :]\n                                samples_removed += wakeword_samples_to_remove\n                                samples_to_remove = 0\n\n                        wakeword_samples_to_remove = 0\n\n                    if self.use_extended_logging:\n                        logger.debug(\n                            \"Debug: Checking if stop_recording_on_voice_deactivity is True\"\n                        )\n                    # Stop the recording if silence is detected after speech\n                    if self.stop_recording_on_voice_deactivity:\n                        if self.use_extended_logging:\n                            logger.debug(\"Debug: Determining if speech is detected\")\n                        is_speech = (\n                            self._is_silero_speech(data)\n                            if self.silero_deactivity_detection\n                            else self._is_webrtc_speech(data, True)\n                        )\n\n                        if self.use_extended_logging:\n                            logger.debug(\"Debug: Formatting speech_end_silence_start\")\n                        if not self.speech_end_silence_start:\n                            str_speech_end_silence_start = \"0\"\n                        else:\n                            str_speech_end_silence_start = (\n                                datetime.datetime.fromtimestamp(\n                                    self.speech_end_silence_start\n                                ).strftime(\"%H:%M:%S.%f\")[:-3]\n                            )\n                        if self.use_extended_logging:\n                            logger.debug(\n                                f\"is_speech: {is_speech}, str_speech_end_silence_start: {str_speech_end_silence_start}\"\n                            )\n\n                        if self.use_extended_logging:\n                            logger.debug(\"Debug: Checking if speech is not detected\")\n                        if not is_speech:\n                            if self.use_extended_logging:\n                                logger.debug(\"Debug: Handling voice deactivity\")\n                            # Voice deactivity was detected, so we start\n                            # measuring silence time before stopping recording\n                            if self.speech_end_silence_start == 0 and (\n                                time.time() - self.recording_start_time\n                                > self.min_length_of_recording\n                            ):\n\n                                self.speech_end_silence_start = time.time()\n                                self.awaiting_speech_end = True\n                                if self.on_turn_detection_start:\n                                    if self.use_extended_logging:\n                                        logger.debug(\n                                            \"Debug: Calling on_turn_detection_start\"\n                                        )\n\n                                    self._run_callback(self.on_turn_detection_start)\n\n                            if self.use_extended_logging:\n                                logger.debug(\n                                    \"Debug: Checking early transcription conditions\"\n                                )\n                            if (\n                                self.speech_end_silence_start\n                                and self.early_transcription_on_silence\n                                and len(self.frames) > 0\n                                and (\n                                    time.time() - self.speech_end_silence_start\n                                    > self.early_transcription_on_silence\n                                )\n                                and self.allowed_to_early_transcribe\n                            ):\n                                if self.use_extended_logging:\n                                    logger.debug(\n                                        \"Debug:Adding early transcription request\"\n                                    )\n                                self.transcribe_count += 1\n                                audio_array = np.frombuffer(\n                                    b\"\".join(self.frames), dtype=np.int16\n                                )\n                                audio = (\n                                    audio_array.astype(np.float32) / INT16_MAX_ABS_VALUE\n                                )\n\n                                if self.use_extended_logging:\n                                    logger.debug(\n                                        \"Debug: early transcription request pipe send\"\n                                    )\n                                self.parent_transcription_pipe.send(\n                                    (audio, self.language, True)\n                                )\n                                if self.use_extended_logging:\n                                    logger.debug(\n                                        \"Debug: early transcription request pipe send return\"\n                                    )\n                                self.allowed_to_early_transcribe = False\n\n                        else:\n                            self.awaiting_speech_end = False\n                            if self.use_extended_logging:\n                                logger.debug(\"Debug: Handling speech detection\")\n                            if self.speech_end_silence_start:\n                                if self.use_extended_logging:\n                                    logger.info(\n                                        \"Resetting self.speech_end_silence_start\"\n                                    )\n\n                                if self.speech_end_silence_start != 0:\n                                    self.speech_end_silence_start = 0\n                                    if self.on_turn_detection_stop:\n                                        if self.use_extended_logging:\n                                            logger.debug(\n                                                \"Debug: Calling on_turn_detection_stop\"\n                                            )\n                                        self._run_callback(self.on_turn_detection_stop)\n\n                                self.allowed_to_early_transcribe = True\n\n                        if self.use_extended_logging:\n                            logger.debug(\n                                \"Debug: Checking if silence duration exceeds threshold\"\n                            )\n                        # Wait for silence to stop recording after speech\n                        if (\n                            self.speech_end_silence_start\n                            and time.time() - self.speech_end_silence_start\n                            >= self.post_speech_silence_duration\n                        ):\n\n                            if self.on_vad_stop:\n                                self._run_callback(self.on_vad_stop)\n\n                            if self.use_extended_logging:\n                                logger.debug(\"Debug: Formatting silence start time\")\n                            # Get time in desired format (HH:MM:SS.nnn)\n                            silence_start_time = datetime.datetime.fromtimestamp(\n                                self.speech_end_silence_start\n                            ).strftime(\"%H:%M:%S.%f\")[:-3]\n\n                            if self.use_extended_logging:\n                                logger.debug(\"Debug: Calculating time difference\")\n                            # Calculate time difference\n                            time_diff = time.time() - self.speech_end_silence_start\n\n                            if self.use_extended_logging:\n                                logger.debug(\n                                    \"Debug: Logging voice deactivity detection\"\n                                )\n                                logger.info(\n                                    f\"voice deactivity detected at {silence_start_time}, \"\n                                    f\"time since silence start: {time_diff:.3f} seconds\"\n                                )\n\n                                logger.debug(\n                                    \"Debug: Appending data to frames and stopping recording\"\n                                )\n                            self.frames.append(data)\n                            self.stop()\n                            if not self.is_recording:\n                                if self.speech_end_silence_start != 0:\n                                    self.speech_end_silence_start = 0\n                                    if self.on_turn_detection_stop:\n                                        if self.use_extended_logging:\n                                            logger.debug(\n                                                \"Debug: Calling on_turn_detection_stop\"\n                                            )\n                                        self._run_callback(self.on_turn_detection_stop)\n\n                                if self.use_extended_logging:\n                                    logger.debug(\n                                        \"Debug: Handling non-wake word scenario\"\n                                    )\n                            else:\n                                if self.use_extended_logging:\n                                    logger.debug(\n                                        \"Debug: Setting failed_stop_attempt to True\"\n                                    )\n                                failed_stop_attempt = True\n\n                            self.awaiting_speech_end = False\n\n                if self.use_extended_logging:\n                    logger.debug(\"Debug: Checking if recording stopped\")\n                if not self.is_recording and was_recording:\n                    if self.use_extended_logging:\n                        logger.debug(\"Debug: Resetting after stopping recording\")\n                    # Reset after stopping recording to ensure clean state\n                    self.stop_recording_on_voice_deactivity = False\n\n                if self.use_extended_logging:\n                    logger.debug(\"Debug: Checking Silero time\")\n                if time.time() - self.silero_check_time > 0.1:\n                    self.silero_check_time = 0\n\n                if self.use_extended_logging:\n                    logger.debug(\"Debug: Handling wake word timeout\")\n                # Handle wake word timeout (waited to long initiating\n                # speech after wake word detection)\n                if (\n                    self.wake_word_detect_time\n                    and time.time() - self.wake_word_detect_time\n                    > self.wake_word_timeout\n                ):\n\n                    self.wake_word_detect_time = 0\n                    if self.wakeword_detected and self.on_wakeword_timeout:\n                        if self.use_extended_logging:\n                            logger.debug(\"Debug: Calling on_wakeword_timeout\")\n                        self._run_callback(self.on_wakeword_timeout)\n                    self.wakeword_detected = False\n\n                if self.use_extended_logging:\n                    logger.debug(\"Debug: Updating was_recording\")\n                was_recording = self.is_recording\n\n                if self.use_extended_logging:\n                    logger.debug(\n                        \"Debug: Checking if recording and not failed stop attempt\"\n                    )\n                if self.is_recording and not failed_stop_attempt:\n                    if self.use_extended_logging:\n                        logger.debug(\"Debug: Appending data to frames\")\n                    self.frames.append(data)\n\n                if self.use_extended_logging:\n                    logger.debug(\n                        \"Debug: Checking if not recording or speech end silence start\"\n                    )\n                if not self.is_recording or self.speech_end_silence_start:\n                    if self.use_extended_logging:\n                        logger.debug(\"Debug: Appending data to audio buffer\")\n                    self.audio_buffer.append(data)\n\n        except Exception as e:\n            logger.debug(\"Debug: Caught exception in main try block\")\n            if not self.interrupt_stop_event.is_set():\n                logger.error(\n                    f\"Unhandled exeption in _recording_worker: {e}\", exc_info=True\n                )\n                raise\n\n        if self.use_extended_logging:\n            logger.debug(\"Debug: Exiting _recording_worker method\")\n\n    def _realtime_worker(self):\n        \"\"\"\n        Performs real-time transcription if the feature is enabled.\n\n        The method is responsible transcribing recorded audio frames\n          in real-time based on the specified resolution interval.\n        The transcribed text is stored in `self.realtime_transcription_text`\n          and a callback\n        function is invoked with this text if specified.\n        \"\"\"\n\n        try:\n\n            logger.debug(\"Starting realtime worker\")\n\n            # Return immediately if real-time transcription is not enabled\n            if not self.enable_realtime_transcription:\n                return\n\n            # Track time of last transcription\n            last_transcription_time = time.time()\n\n            while self.is_running:\n\n                if self.is_recording:\n\n                    # MODIFIED SLEEP LOGIC:\n                    # Wait until realtime_processing_pause has elapsed,\n                    # but check often so we can respond to changes quickly.\n                    while (\n                        time.time() - last_transcription_time\n                    ) < self.realtime_processing_pause:\n                        time.sleep(0.001)\n                        if not self.is_running or not self.is_recording:\n                            break\n\n                    if self.awaiting_speech_end:\n                        time.sleep(0.001)\n                        continue\n\n                    # Update transcription time\n                    last_transcription_time = time.time()\n\n                    # Convert the buffer frames to a NumPy array\n                    audio_array = np.frombuffer(b\"\".join(self.frames), dtype=np.int16)\n\n                    logger.debug(f\"Current realtime buffer size: {len(audio_array)}\")\n\n                    # Normalize the array to a [-1, 1] range\n                    audio_array = audio_array.astype(np.float32) / INT16_MAX_ABS_VALUE\n\n                    if self.use_main_model_for_realtime:\n                        with self.transcription_lock:\n                            try:\n                                self.parent_transcription_pipe.send(\n                                    (audio_array, self.language, True)\n                                )\n                                if self.parent_transcription_pipe.poll(\n                                    timeout=5\n                                ):  # Wait for 5 seconds\n                                    logger.debug(\n                                        \"Receive from realtime worker after transcription request to main model\"\n                                    )\n                                    status, result = (\n                                        self.parent_transcription_pipe.recv()\n                                    )\n                                    if status == \"success\":\n                                        segments, info = result\n                                        self.detected_realtime_language = (\n                                            info.language\n                                            if info.language_probability > 0\n                                            else None\n                                        )\n                                        self.detected_realtime_language_probability = (\n                                            info.language_probability\n                                        )\n                                        realtime_text = segments\n                                        logger.debug(\n                                            f\"Realtime text detected with main model: {realtime_text}\"\n                                        )\n                                    else:\n                                        logger.error(\n                                            f\"Realtime transcription error: {result}\"\n                                        )\n                                        continue\n                                else:\n                                    logger.warning(\"Realtime transcription timed out\")\n                                    continue\n                            except Exception as e:\n                                logger.error(\n                                    f\"Error in realtime transcription: {str(e)}\",\n                                    exc_info=True,\n                                )\n                                continue\n                    else:\n                        # Perform transcription and assemble the text\n                        if self.normalize_audio:\n                            # normalize audio to -0.95 dBFS\n                            if audio_array is not None and audio_array.size > 0:\n                                peak = np.max(np.abs(audio_array))\n                                if peak > 0:\n                                    audio_array = (audio_array / peak) * 0.95\n\n                        if self.realtime_batch_size > 0:\n                            segments, info = self.realtime_model_type.transcribe(\n                                audio_array,\n                                language=self.language if self.language else None,\n                                beam_size=self.beam_size_realtime,\n                                initial_prompt=self.initial_prompt_realtime,\n                                suppress_tokens=self.suppress_tokens,\n                                batch_size=self.realtime_batch_size,\n                                vad_filter=self.faster_whisper_vad_filter,\n                            )\n                        else:\n                            segments, info = self.realtime_model_type.transcribe(\n                                audio_array,\n                                language=self.language if self.language else None,\n                                beam_size=self.beam_size_realtime,\n                                initial_prompt=self.initial_prompt_realtime,\n                                suppress_tokens=self.suppress_tokens,\n                                vad_filter=self.faster_whisper_vad_filter,\n                            )\n\n                        self.detected_realtime_language = (\n                            info.language if info.language_probability > 0 else None\n                        )\n                        self.detected_realtime_language_probability = (\n                            info.language_probability\n                        )\n                        realtime_text = \" \".join(seg.text for seg in segments)\n                        logger.debug(f\"Realtime text detected: {realtime_text}\")\n\n                    # double check recording state\n                    # because it could have changed mid-transcription\n                    if (\n                        self.is_recording\n                        and time.time() - self.recording_start_time\n                        > self.init_realtime_after_seconds\n                    ):\n\n                        self.realtime_transcription_text = realtime_text\n                        self.realtime_transcription_text = (\n                            self.realtime_transcription_text.strip()\n                        )\n\n                        self.text_storage.append(self.realtime_transcription_text)\n\n                        # Take the last two texts in storage, if they exist\n                        if len(self.text_storage) >= 2:\n                            last_two_texts = self.text_storage[-2:]\n\n                            # Find the longest common prefix\n                            # between the two texts\n                            prefix = os.path.commonprefix(\n                                [last_two_texts[0], last_two_texts[1]]\n                            )\n\n                            # This prefix is the text that was transcripted\n                            # two times in the same way\n                            # Store as \"safely detected text\"\n                            if len(prefix) >= len(self.realtime_stabilized_safetext):\n\n                                # Only store when longer than the previous\n                                # as additional security\n                                self.realtime_stabilized_safetext = prefix\n\n                        # Find parts of the stabilized text\n                        # in the freshly transcripted text\n                        matching_pos = self._find_tail_match_in_text(\n                            self.realtime_stabilized_safetext,\n                            self.realtime_transcription_text,\n                        )\n\n                        if matching_pos < 0:\n                            # pick which text to send\n                            text_to_send = (\n                                self.realtime_stabilized_safetext\n                                if self.realtime_stabilized_safetext\n                                else self.realtime_transcription_text\n                            )\n                            # preprocess once\n                            processed = self._preprocess_output(text_to_send, True)\n                            # invoke on its own thread\n                            self._run_callback(\n                                self._on_realtime_transcription_stabilized, processed\n                            )\n\n                        else:\n                            # We found parts of the stabilized text\n                            # in the transcripted text\n                            # We now take the stabilized text\n                            # and add only the freshly transcripted part to it\n                            output_text = (\n                                self.realtime_stabilized_safetext\n                                + self.realtime_transcription_text[matching_pos:]\n                            )\n\n                            # This yields us the \"left\" text part as stabilized\n                            # AND at the same time delivers fresh detected\n                            # parts on the first run without the need for\n                            # two transcriptions\n                            self._run_callback(\n                                self._on_realtime_transcription_stabilized,\n                                self._preprocess_output(output_text, True),\n                            )\n\n                        # Invoke the callback with the transcribed text\n                        self._run_callback(\n                            self._on_realtime_transcription_update,\n                            self._preprocess_output(\n                                self.realtime_transcription_text, True\n                            ),\n                        )\n\n                # If not recording, sleep briefly before checking again\n                else:\n                    time.sleep(TIME_SLEEP)\n\n        except Exception as e:\n            logger.error(f\"Unhandled exeption in _realtime_worker: {e}\", exc_info=True)\n            raise\n\n    def _is_silero_speech(self, chunk):\n        \"\"\"\n        Returns true if speech is detected in the provided audio data\n\n        Args:\n            data (bytes): raw bytes of audio data (1024 raw bytes with\n            16000 sample rate and 16 bits per sample)\n        \"\"\"\n        if self.sample_rate != 16000:\n            pcm_data = np.frombuffer(chunk, dtype=np.int16)\n            data_16000 = signal.resample_poly(pcm_data, 16000, self.sample_rate)\n            chunk = data_16000.astype(np.int16).tobytes()\n\n        self.silero_working = True\n        audio_chunk = np.frombuffer(chunk, dtype=np.int16)\n        audio_chunk = audio_chunk.astype(np.float32) / INT16_MAX_ABS_VALUE\n        vad_prob = self.silero_vad_model(\n            torch.from_numpy(audio_chunk), SAMPLE_RATE\n        ).item()\n        is_silero_speech_active = vad_prob > (1 - self.silero_sensitivity)\n        if is_silero_speech_active:\n            if not self.is_silero_speech_active and self.use_extended_logging:\n                logger.info(\n                    f\"{bcolors.OKGREEN}Silero VAD detected speech{bcolors.ENDC}\"\n                )\n        elif self.is_silero_speech_active and self.use_extended_logging:\n            logger.info(f\"{bcolors.WARNING}Silero VAD detected silence{bcolors.ENDC}\")\n        self.is_silero_speech_active = is_silero_speech_active\n        self.silero_working = False\n        return is_silero_speech_active\n\n    def _is_webrtc_speech(self, chunk, all_frames_must_be_true=False):\n        \"\"\"\n        Returns true if speech is detected in the provided audio data\n\n        Args:\n            data (bytes): raw bytes of audio data (1024 raw bytes with\n            16000 sample rate and 16 bits per sample)\n        \"\"\"\n        speech_str = f\"{bcolors.OKGREEN}WebRTC VAD detected speech{bcolors.ENDC}\"\n        silence_str = f\"{bcolors.WARNING}WebRTC VAD detected silence{bcolors.ENDC}\"\n        if self.sample_rate != 16000:\n            pcm_data = np.frombuffer(chunk, dtype=np.int16)\n            data_16000 = signal.resample_poly(pcm_data, 16000, self.sample_rate)\n            chunk = data_16000.astype(np.int16).tobytes()\n\n        # Number of audio frames per millisecond\n        frame_length = int(16000 * 0.01)  # for 10ms frame\n        num_frames = int(len(chunk) / (2 * frame_length))\n        speech_frames = 0\n\n        for i in range(num_frames):\n            start_byte = i * frame_length * 2\n            end_byte = start_byte + frame_length * 2\n            frame = chunk[start_byte:end_byte]\n            if self.webrtc_vad_model.is_speech(frame, 16000):\n                speech_frames += 1\n                if not all_frames_must_be_true:\n                    if self.debug_mode:\n                        logger.info(\n                            f\"Speech detected in frame {i + 1}\" f\" of {num_frames}\"\n                        )\n                    if not self.is_webrtc_speech_active and self.use_extended_logging:\n                        logger.info(speech_str)\n                    self.is_webrtc_speech_active = True\n                    return True\n        if all_frames_must_be_true:\n            if self.debug_mode and speech_frames == num_frames:\n                logger.info(\n                    f\"Speech detected in {speech_frames} of \" f\"{num_frames} frames\"\n                )\n            elif self.debug_mode:\n                logger.info(f\"Speech not detected in all {num_frames} frames\")\n            speech_detected = speech_frames == num_frames\n            if (\n                speech_detected\n                and not self.is_webrtc_speech_active\n                and self.use_extended_logging\n            ):\n                logger.info(speech_str)\n            elif (\n                not speech_detected\n                and self.is_webrtc_speech_active\n                and self.use_extended_logging\n            ):\n                logger.info(silence_str)\n            self.is_webrtc_speech_active = speech_detected\n            return speech_detected\n        else:\n            if self.debug_mode:\n                logger.info(f\"Speech not detected in any of {num_frames} frames\")\n            if self.is_webrtc_speech_active and self.use_extended_logging:\n                logger.info(silence_str)\n            self.is_webrtc_speech_active = False\n            return False\n\n    def _check_voice_activity(self, data):\n        \"\"\"\n        Initiate check if voice is active based on the provided data.\n\n        Args:\n            data: The audio data to be checked for voice activity.\n        \"\"\"\n        self._is_webrtc_speech(data)\n\n        # First quick performing check for voice activity using WebRTC\n        if self.is_webrtc_speech_active:\n\n            if not self.silero_working:\n                self.silero_working = True\n\n                # Run the intensive check in a separate thread\n                threading.Thread(target=self._is_silero_speech, args=(data,)).start()\n\n    def clear_audio_queue(self):\n        \"\"\"\n        Safely empties the audio queue to ensure no remaining audio\n        fragments get processed e.g. after waking up the recorder.\n        \"\"\"\n        self.audio_buffer.clear()\n        try:\n            while True:\n                self.audio_queue.get_nowait()\n        except:\n            # PyTorch's mp.Queue doesn't have a specific Empty exception\n            # so we catch any exception that might occur when the queue is empty\n            pass\n\n    def _is_voice_active(self):\n        \"\"\"\n        Determine if voice is active.\n\n        Returns:\n            bool: True if voice is active, False otherwise.\n        \"\"\"\n        return self.is_webrtc_speech_active and self.is_silero_speech_active\n\n    def _set_state(self, new_state):\n        \"\"\"\n        Update the current state of the recorder and execute\n        corresponding state-change callbacks.\n\n        Args:\n            new_state (str): The new state to set.\n\n        \"\"\"\n        # Check if the state has actually changed\n        if new_state == self.state:\n            return\n\n        # Store the current state for later comparison\n        old_state = self.state\n\n        # Update to the new state\n        self.state = new_state\n\n        # Log the state change\n        logger.info(f\"State changed from '{old_state}' to '{new_state}'\")\n\n        # Execute callbacks based on transitioning FROM a particular state\n        if old_state == \"listening\":\n            if self.on_vad_detect_stop:\n                self._run_callback(self.on_vad_detect_stop)\n        elif old_state == \"wakeword\":\n            if self.on_wakeword_detection_end:\n                self._run_callback(self.on_wakeword_detection_end)\n\n        # Execute callbacks based on transitioning TO a particular state\n        if new_state == \"listening\":\n            if self.on_vad_detect_start:\n                self._run_callback(self.on_vad_detect_start)\n            self._set_spinner(\"speak now\")\n            if self.spinner and self.halo:\n                self.halo._interval = 250\n        elif new_state == \"wakeword\":\n            if self.on_wakeword_detection_start:\n                self._run_callback(self.on_wakeword_detection_start)\n            self._set_spinner(f\"say {self.wake_words}\")\n            if self.spinner and self.halo:\n                self.halo._interval = 500\n        elif new_state == \"transcribing\":\n            self._set_spinner(\"transcribing\")\n            if self.spinner and self.halo:\n                self.halo._interval = 50\n        elif new_state == \"recording\":\n            self._set_spinner(\"recording\")\n            if self.spinner and self.halo:\n                self.halo._interval = 100\n        elif new_state == \"inactive\":\n            if self.spinner and self.halo:\n                self.halo.stop()\n                self.halo = None\n\n    def _set_spinner(self, text):\n        \"\"\"\n        Update the spinner's text or create a new\n        spinner with the provided text.\n\n        Args:\n            text (str): The text to be displayed alongside the spinner.\n        \"\"\"\n        if self.spinner:\n            # If the Halo spinner doesn't exist, create and start it\n            if self.halo is None:\n                self.halo = halo.Halo(text=text)\n                self.halo.start()\n            # If the Halo spinner already exists, just update the text\n            else:\n                self.halo.text = text\n\n    def _preprocess_output(self, text, preview=False):\n        \"\"\"\n        Preprocesses the output text by removing any leading or trailing\n        whitespace, converting all whitespace sequences to a single space\n        character, and capitalizing the first character of the text.\n\n        Args:\n            text (str): The text to be preprocessed.\n\n        Returns:\n            str: The preprocessed text.\n        \"\"\"\n        text = re.sub(r\"\\s+\", \" \", text.strip())\n\n        if self.ensure_sentence_starting_uppercase:\n            if text:\n                text = text[0].upper() + text[1:]\n\n        # Ensure the text ends with a proper punctuation\n        # if it ends with an alphanumeric character\n        if not preview:\n            if self.ensure_sentence_ends_with_period:\n                if text and text[-1].isalnum():\n                    text += \".\"\n\n        return text\n\n    def _find_tail_match_in_text(self, text1, text2, length_of_match=10):\n        \"\"\"\n        Find the position where the last 'n' characters of text1\n        match with a substring in text2.\n\n        This method takes two texts, extracts the last 'n' characters from\n        text1 (where 'n' is determined by the variable 'length_of_match'), and\n        searches for an occurrence of this substring in text2, starting from\n        the end of text2 and moving towards the beginning.\n\n        Parameters:\n        - text1 (str): The text containing the substring that we want to find\n          in text2.\n        - text2 (str): The text in which we want to find the matching\n          substring.\n        - length_of_match(int): The length of the matching string that we are\n          looking for\n\n        Returns:\n        int: The position (0-based index) in text2 where the matching\n          substring starts. If no match is found or either of the texts is\n          too short, returns -1.\n        \"\"\"\n\n        # Check if either of the texts is too short\n        if len(text1) < length_of_match or len(text2) < length_of_match:\n            return -1\n\n        # The end portion of the first text that we want to compare\n        target_substring = text1[-length_of_match:]\n\n        # Loop through text2 from right to left\n        for i in range(len(text2) - length_of_match + 1):\n            # Extract the substring from text2\n            # to compare with the target_substring\n            current_substring = text2[len(text2) - i - length_of_match : len(text2) - i]\n\n            # Compare the current_substring with the target_substring\n            if current_substring == target_substring:\n                # Position in text2 where the match starts\n                return len(text2) - i\n\n        return -1\n\n    def _on_realtime_transcription_stabilized(self, text):\n        \"\"\"\n        Callback method invoked when the real-time transcription stabilizes.\n\n        This method is called internally when the transcription text is\n        considered \"stable\" meaning it's less likely to change significantly\n        with additional audio input. It notifies any registered external\n        listener about the stabilized text if recording is still ongoing.\n        This is particularly useful for applications that need to display\n        live transcription results to users and want to highlight parts of the\n        transcription that are less likely to change.\n\n        Args:\n            text (str): The stabilized transcription text.\n        \"\"\"\n        if self.on_realtime_transcription_stabilized:\n            if self.is_recording:\n                self._run_callback(self.on_realtime_transcription_stabilized, text)\n\n    def _on_realtime_transcription_update(self, text):\n        \"\"\"\n        Callback method invoked when there's an update in the real-time\n        transcription.\n\n        This method is called internally whenever there's a change in the\n        transcription text, notifying any registered external listener about\n        the update if recording is still ongoing. This provides a mechanism\n        for applications to receive and possibly display live transcription\n        updates, which could be partial and still subject to change.\n\n        Args:\n            text (str): The updated transcription text.\n        \"\"\"\n        if self.on_realtime_transcription_update:\n            if self.is_recording:\n                self._run_callback(self.on_realtime_transcription_update, text)\n\n    def __enter__(self):\n        \"\"\"\n        Method to setup the context manager protocol.\n\n        This enables the instance to be used in a `with` statement, ensuring\n        proper resource management. When the `with` block is entered, this\n        method is automatically called.\n\n        Returns:\n            self: The current instance of the class.\n        \"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"\n        Method to define behavior when the context manager protocol exits.\n\n        This is called when exiting the `with` block and ensures that any\n        necessary cleanup or resource release processes are executed, such as\n        shutting down the system properly.\n\n        Args:\n            exc_type (Exception or None): The type of the exception that\n              caused the context to be exited, if any.\n            exc_value (Exception or None): The exception instance that caused\n              the context to be exited, if any.\n            traceback (Traceback or None): The traceback corresponding to the\n              exception, if any.\n        \"\"\"\n        self.shutdown()\n"
        }
    ]
}